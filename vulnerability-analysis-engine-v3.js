// Enhanced Vulnerability Analysis Engine V3
// Adds SLA Gating, POC Assignment Rules, and Smart POAM Descriptions
// Now with Baseline and Legacy Finding Support

console.log('âœ… vulnerability-analysis-engine-v3.js loaded successfully');

// Note: LEGACY_THRESHOLD_DAYS and RECENT_THRESHOLD_DAYS are defined in vulnerability-tracking.js

// POAM Template System for Automatic Field Population
const POAM_TEMPLATES = {
    PATCHING_UPDATES: {
        type: 'Patching/Updates',
        mitigation: 'Apply the latest vendor-provided patch or update to remediate the vulnerability.',
        milestones: [
            'Identify affected systems and retrieve the patch',
            'Test the patch in a controlled environment',
            'Deploy the patch to production systems',
            'Verify and close the POAM once the update is confirmed'
        ],
        impactedControls: ['SI-2'], // Flaw Remediation
        resources: 'Patch management team, system administrators, change management board',
        estimatedEffort: 'Medium - Depends on patch availability and testing requirements'
    },
    CONFIGURATION_CM: {
        type: 'Configuration/CM Controls',
        mitigation: 'Adjust system configuration to comply with required security baselines.',
        milestones: [
            'Review current configuration settings',
            'Implement the required configuration change',
            'Test to ensure compliance with the control',
            'Document and verify compliance'
        ],
        impactedControls: ['CM-6'], // Configuration Management
        resources: 'System administrators, security compliance team, configuration management',
        estimatedEffort: 'Low to Medium - Depends on complexity of configuration change'
    },
    SERVICE_REMEDIATION: {
        type: 'Service Remediation',
        mitigation: 'Update or reconfigure affected services to address security vulnerabilities.',
        milestones: [
            'Identify affected services and dependencies',
            'Update service configuration or version',
            'Test service functionality after changes',
            'Deploy to production and monitor for issues'
        ],
        impactedControls: ['SI-2', 'CM-6'],
        resources: 'Service owners, system administrators, DevOps team',
        estimatedEffort: 'Medium - Requires service downtime and testing'
    },
    ACCESS_CONTROL: {
        type: 'Access Control',
        mitigation: 'Modify user permissions and access controls to meet security requirements.',
        milestones: [
            'Review current access permissions',
            'Implement required access control changes',
            'Validate changes with affected users',
            'Document and audit access modifications'
        ],
        impactedControls: ['AC-3'], // Access Enforcement
        resources: 'System administrators, security team, user management',
        estimatedEffort: 'Low - Typically straightforward permission changes'
    },
    NETWORK_SECURITY: {
        type: 'Network Security',
        mitigation: 'Update network configurations and firewall rules to address vulnerabilities.',
        milestones: [
            'Analyze current network configuration',
            'Update firewall rules and network settings',
            'Test network connectivity and security',
            'Monitor for any issues or regressions'
        ],
        impactedControls: ['SC-7'], // Boundary Protection
        resources: 'Network engineers, security team, firewall administrators',
        estimatedEffort: 'Medium - Requires careful network changes and testing'
    },
    UNKNOWN: {
        type: 'Unknown/Other',
        mitigation: 'Further investigation required to determine appropriate remediation approach.',
        milestones: [
            'Analyze vulnerability details and impact',
            'Research appropriate remediation strategies',
            'Develop and implement remediation plan',
            'Test and validate remediation effectiveness'
        ],
        impactedControls: ['SI-2'],
        resources: 'Security team, system administrators, subject matter experts',
        estimatedEffort: 'Unknown - Requires further analysis'
    }
};

// Legacy Detection Functions
function isLegacyFinding(firstDetectedDate) {
    if (!firstDetectedDate) return false;
    
    const detectionDate = new Date(firstDetectedDate);
    const now = new Date();
    const daysSinceDetection = Math.floor((now - detectionDate) / (1000 * 60 * 60 * 24));
    
    return daysSinceDetection > LEGACY_THRESHOLD_DAYS;
}

function isRecentFinding(firstDetectedDate) {
    if (!firstDetectedDate) return false;
    
    const detectionDate = new Date(firstDetectedDate);
    const now = new Date();
    const daysSinceDetection = Math.floor((now - detectionDate) / (1000 * 60 * 60 * 24));
    
    return daysSinceDetection <= RECENT_THRESHOLD_DAYS;
}

function calculateDueDateForLegacy(riskLevel, firstDetectedDate) {
    const now = new Date();
    let slaDays = 120; // Default SLA for moderate
    
    // Updated SLA based on risk level
    switch (riskLevel?.toLowerCase()) {
        case 'critical':
            slaDays = 30;
            break;
        case 'high':
            slaDays = 60;
            break;
        case 'medium':
        case 'moderate':
            slaDays = 120;
            break;
        case 'low':
            slaDays = 240;
            break;
    }
    
    // For legacy findings, calculate from current date (not original detection)
    const dueDate = new Date(now.getTime() + (slaDays * 24 * 60 * 60 * 1000));
    return dueDate.toISOString().split('T')[0]; // Return YYYY-MM-DD format
}

function calculateDueDateForRecent(riskLevel, firstDetectedDate) {
    // For recent findings, use standard SLA from detection date
    let slaDays = 120; // Default SLA for moderate
    
    switch (riskLevel?.toLowerCase()) {
        case 'critical':
            slaDays = 30;
            break;
        case 'high':
            slaDays = 60;
            break;
        case 'medium':
        case 'moderate':
            slaDays = 120;
            break;
        case 'low':
            slaDays = 240;
            break;
    }
    
    const detectionDate = new Date(firstDetectedDate);
    const dueDate = new Date(detectionDate.getTime() + (slaDays * 24 * 60 * 60 * 1000));
    return dueDate.toISOString().split('T')[0]; // Return YYYY-MM-DD format
}

class VulnerabilityAnalysisEngineV3 extends VulnerabilityAnalysisEngineV2 {
    constructor() {
        super();
        
        // Baseline mode configuration
        this.isBaselineMode = false;
        this.baselinePOAMs = new Set(); // Store baseline POAM IDs for comparison
        
        // SLA Configuration (days by severity)
        this.slaConfig = {
            critical: 30,
            high: 60,
            medium: 120,
            moderate: 120,
            low: 240
        };
        
        // POC Assignment Rules (priority-based)
        this.pocRules = [
            {
                name: "Windows Systems Team",
                priority: 1,
                conditions: {
                    platform: ["windows"],
                    remediationType: ["patch_cycle", "kb_install"]
                }
            },
            {
                name: "Linux Systems Team",
                priority: 2,
                conditions: {
                    platform: ["linux"],
                    remediationType: ["patch_cycle", "package_upgrade"]
                }
            },
            {
                name: "Application Development Team",
                priority: 3,
                conditions: {
                    component: ["java", "dotnet", "python", "nodejs", "spring_framework"]
                }
            },
            {
                name: "Web Infrastructure Team",
                priority: 4,
                conditions: {
                    component: ["apache", "nginx", "iis", "tomcat"]
                }
            },
            {
                name: "Desktop Engineering Team",
                priority: 5,
                conditions: {
                    component: ["firefox", "chrome", "edge", "safari"],
                    remediationType: ["software_upgrade"]
                }
            },
            {
                name: "Network Security Team",
                priority: 6,
                conditions: {
                    component: ["openssh", "ssl", "tls"],
                    remediationType: ["config_change", "operational_mitigation"]
                }
            },
            {
                name: "Security Operations Team",
                priority: 99,
                conditions: {},
                default: true
            }
        ];
        
        this.poamsCreated = 0;
        this.poamsSkipped = 0;
        this.skipReasons = {};
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // BASELINE MANAGEMENT METHODS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    setBaselineMode(enabled) {
        this.isBaselineMode = enabled;
        console.log(`ğŸ“Š Baseline mode ${enabled ? 'ENABLED' : 'DISABLED'}`);
    }
    
    addToBaseline(poamId) {
        this.baselinePOAMs.add(poamId);
        console.log(`ğŸ“Š Added POAM ${poamId} to baseline`);
    }
    
    isInBaseline(poamId) {
        return this.baselinePOAMs.has(poamId);
    }
    
    generateBaselineKey(vulnerability) {
        // Create a unique key for baseline comparison based on vulnerability characteristics
        return `${vulnerability.cve || vulnerability.vulnerabilityName || vulnerability.title}_${vulnerability.asset || vulnerability.hostname}`;
    }
    
    isNearExpiry(dueDate) {
        if (!dueDate) return false;
        
        const now = new Date();
        const due = new Date(dueDate);
        const daysUntilDue = Math.floor((due - now) / (1000 * 60 * 60 * 24));
        
        return daysUntilDue <= 10 && daysUntilDue >= 0; // Within 10 days of due date
    }
    
    performBaselineComparison() {
        console.log('ğŸ“Š Performing baseline comparison...');
        
        this.groupedPOAMs.forEach(poam => {
            const baselineKey = this.generateBaselineKey(poam);
            
            // Check if this POAM matches a baseline POAM
            if (this.isInBaseline(baselineKey)) {
                // This is a known finding - check if it's near expiry
                if (this.isNearExpiry(poam.dueDate)) {
                    poam.status = 'overdue';
                    poam.baselineStatus = 'expired';
                    console.log(`âš ï¸ Baseline POAM ${poam.id} is near expiry and marked as overdue`);
                } else {
                    poam.baselineStatus = 'active';
                }
            } else {
                // This is a new finding not in baseline
                poam.baselineStatus = 'new';
            }
        });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // POAM TEMPLATE SYSTEM
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    determineFindingType(vulnerability, remediation) {
        const title = (vulnerability.title || vulnerability.vulnerabilityName || '').toLowerCase();
        const description = (vulnerability.description || '').toLowerCase();
        const remediationType = remediation?.remediationType || '';
        const actionText = (remediation?.actionText || '').toLowerCase();
        
        // Check for patching/update related findings
        if (this.isPatchingFinding(title, description, remediationType, actionText)) {
            return 'PATCHING_UPDATES';
        }
        
        // Check for configuration related findings
        if (this.isConfigurationFinding(title, description, remediationType, actionText)) {
            return 'CONFIGURATION_CM';
        }
        
        // Check for service related findings
        if (this.isServiceFinding(title, description, remediationType, actionText)) {
            return 'SERVICE_REMEDIATION';
        }
        
        // Check for access control findings
        if (this.isAccessControlFinding(title, description, remediationType, actionText)) {
            return 'ACCESS_CONTROL';
        }
        
        // Check for network security findings
        if (this.isNetworkFinding(title, description, remediationType, actionText)) {
            return 'NETWORK_SECURITY';
        }
        
        // Default to unknown
        return 'UNKNOWN';
    }
    
    isPatchingFinding(title, description, remediationType, actionText) {
        const patchKeywords = [
            'patch', 'update', 'upgrade', 'version', 'vulnerability', 'cve',
            'security update', 'hotfix', 'service pack', 'cumulative update'
        ];
        
        const text = [title, description, actionText].join(' ');
        
        return patchKeywords.some(keyword => text.includes(keyword)) ||
               remediationType.toLowerCase().includes('patch') ||
               remediationType.toLowerCase().includes('update');
    }
    
    isConfigurationFinding(title, description, remediationType, actionText) {
        const configKeywords = [
            'configuration', 'setting', 'baseline', 'policy', 'registry',
            'permission', 'parameter', 'option', 'control', 'hardening'
        ];
        
        const text = [title, description, actionText].join(' ');
        
        return configKeywords.some(keyword => text.includes(keyword)) ||
               remediationType.toLowerCase().includes('configuration') ||
               remediationType.toLowerCase().includes('setting');
    }
    
    isServiceFinding(title, description, remediationType, actionText) {
        const serviceKeywords = [
            'service', 'daemon', 'process', 'restart', 'stop', 'start',
            'disable', 'enable', 'configure service'
        ];
        
        const text = [title, description, actionText].join(' ');
        
        return serviceKeywords.some(keyword => text.includes(keyword)) ||
               remediationType.toLowerCase().includes('service');
    }
    
    isAccessControlFinding(title, description, remediationType, actionText) {
        const accessKeywords = [
            'access', 'permission', 'user', 'group', 'role', 'privilege',
            'authentication', 'authorization', 'login', 'account'
        ];
        
        const text = [title, description, actionText].join(' ');
        
        return accessKeywords.some(keyword => text.includes(keyword)) ||
               remediationType.toLowerCase().includes('access');
    }
    
    isNetworkFinding(title, description, remediationType, actionText) {
        const networkKeywords = [
            'firewall', 'port', 'network', 'protocol', 'tcp', 'udp',
            'ip', 'routing', 'switch', 'router', 'network device'
        ];
        
        const text = [title, description, actionText].join(' ');
        
        return networkKeywords.some(keyword => text.includes(keyword)) ||
               remediationType.toLowerCase().includes('network') ||
               remediationType.toLowerCase().includes('firewall');
    }
    
    generateEnhancedMitigationStrategy(vulnerability, remediation) {
        console.log('ğŸ”§ Generating enhanced mitigation strategy for:', vulnerability.title);
        console.log('ğŸ” Vulnerability data:', vulnerability);
        console.log('ğŸ” Available fields:', Object.keys(vulnerability));
        console.log('ğŸ” Solution field:', vulnerability.solution);
        console.log('ğŸ” Remediation data:', remediation);
        
        // Primary Source: Use Solution field if populated
        if (vulnerability.solution && vulnerability.solution.trim() !== '') {
            console.log('ğŸ”§ Using vendor solution as primary source');
            return this.generateVendorAuthoritativeMitigation(vulnerability);
        }
        
        console.log('ğŸ”§ Using fallback mitigation - no solution available');
        // Fallback: Use controlled templates based on finding type
        return this.generateFallbackMitigation(vulnerability, remediation);
    }
    
    generateVendorAuthoritativeMitigation(vulnerability) {
        const solution = vulnerability.solution.trim();
        console.log('ğŸ“‹ Using vendor solution as primary source:', solution);
        
        // Extract key information from solution
        const extracted = this.extractSolutionDetails(solution, vulnerability);
        
        // Generate audit-ready mitigation text
        let mitigation = '';
        
        // Action statement
        if (extracted.action) {
            mitigation += extracted.action;
        } else {
            mitigation += `Apply the vendor-provided remediation`;
        }
        
        // Authority reference
        if (extracted.authority) {
            mitigation += ` in accordance with ${extracted.authority}`;
        }
        
        // Implementation guidance
        mitigation += `. Apply the update using enterprise patch management tools`;
        
        // Validation steps
        mitigation += `. Validate remediation by rescanning affected systems and confirming the installed version meets the required level and the vulnerability is no longer detected`;
        
        console.log('âœ… Generated vendor-authoritative mitigation:', mitigation);
        return mitigation;
    }
    
    extractSolutionDetails(solution, vulnerability) {
        const extracted = {
            action: '',
            authority: '',
            version: '',
            vendor: ''
        };
        
        // Extract product names and versions
        const versionPatterns = [
            /upgrade\s+(\w+)\s+to\s+version\s+(\d+(?:\.\d+)*(?:\.\d+)?)/i,
            /update\s+(\w+)\s+to\s+(\d+(?:\.\d+)*(?:\.\d+)?)/i,
            /(\w+)\s+version\s+(\d+(?:\.\d+)*(?:\.\d+)?)/i,
            /apply\s+patch\s+(.+)/i,
            /install\s+(.+?)\s+patch/i
        ];
        
        for (const pattern of versionPatterns) {
            const match = solution.match(pattern);
            if (match) {
                extracted.action = `Upgrade ${match[1]} to version ${match[2]}`;
                extracted.version = match[2];
                break;
            }
        }
        
        // Extract vendor advisories and CVEs
        const advisoryPatterns = [
            /(?:advisory|bulletin|kb)\s+([A-Z]{2,}-\d{4,}-\d+)/i,
            /([A-Z]{2,}-\d{4,}-\d+)/i,
            /CVE-\d{4}-\d{4,}/gi,
            /KB\d{6,}/gi
        ];
        
        const advisories = [];
        for (const pattern of advisoryPatterns) {
            const matches = solution.match(pattern);
            if (matches) {
                advisories.push(...matches);
            }
        }
        
        if (advisories.length > 0) {
            extracted.authority = advisories.join(', ');
        }
        
        // Extract vendor information
        const vendorPatterns = [
            /mozilla|firefox/i,
            /microsoft|windows|office/i,
            /oracle|java/i,
            /apache|tomcat|iis/i,
            /cisco|ios/i,
            /linux|ubuntu|redhat|centos/i,
            /google|chrome/i
        ];
        
        for (const pattern of vendorPatterns) {
            if (solution.match(pattern)) {
                extracted.vendor = pattern.source.replace(/[|\\]/g, '');
                break;
            }
        }
        
        // If no specific action found, create a generic one
        if (!extracted.action) {
            if (extracted.vendor) {
                extracted.action = `Apply the latest vendor-provided update for ${extracted.vendor}`;
            } else {
                extracted.action = `Apply the latest vendor-provided patch or update`;
            }
        }
        
        return extracted;
    }
    
    generateFallbackMitigation(vulnerability, remediation) {
        console.log('âš ï¸ Using fallback mitigation - no solution field available');
        
        const findingType = this.determineFindingType(vulnerability, remediation);
        const template = POAM_TEMPLATES[findingType];
        
        if (!template) {
            return this.generateGenericMitigation(vulnerability);
        }
        
        // Enhance template with specific details
        let enhancedMitigation = template.mitigation;
        
        // Add specific validation steps
        enhancedMitigation += `. Validate remediation by: 1) confirming the configuration changes are applied, 2) rescanning to verify vulnerability resolution, 3) documenting evidence of compliance`;
        
        // Add reference to absence of vendor fix if applicable
        if (remediation.remediationType && remediation.remediationType.includes('operational_mitigation')) {
            enhancedMitigation = `No vendor patch is currently available for this vulnerability. Implement compensating controls: ${enhancedMitigation}`;
        }
        
        return enhancedMitigation;
    }
    
    generateGenericMitigation(vulnerability) {
        console.log('âš ï¸ Using generic mitigation - no template found');
        
        return `Further investigation required to determine appropriate remediation approach for ${vulnerability.title || 'this vulnerability'}. Analyze the vulnerability details, research vendor guidance, and implement appropriate security controls. Validate remediation through testing and verification procedures.`;
    }
    
    applyPOAMTemplate(poam, findingType, vulnerability, remediation, group) {
        console.log(`ğŸ”§ Applying POAM template for ${findingType} to POAM ${poam.id}`);
        
        // Generate enhanced mitigation strategy
        poam.mitigation = this.generateEnhancedMitigationStrategy(vulnerability, remediation);
        
        // Store affected assets separately for dedicated tab/section
        poam.affectedAssets = this.getAffectedAssetsForDisplay(group);
        console.log(`ğŸ¢ Stored ${poam.affectedAssets.length} affected assets for POAM ${poam.id}`);
        
        const template = POAM_TEMPLATES[findingType];
        
        if (!template) {
            console.warn(`âš ï¸ No template found for finding type: ${findingType}`);
            // Still apply basic fields
            poam.findingType = 'Unknown/Other';
            poam.milestones = [
                'Analyze vulnerability details and impact',
                'Research appropriate remediation strategies',
                'Develop and implement remediation plan',
                'Test and validate remediation effectiveness'
            ];
            poam.impactedControls = ['SI-2'];
            poam.resources = 'Security team, system administrators, subject matter experts';
            poam.estimatedEffort = 'Unknown - Requires further analysis';
        } else {
            // Apply template fields (except mitigation which is already enhanced)
            poam.findingType = template.type;
            poam.milestones = template.milestones;
            poam.impactedControls = template.impactedControls;
            poam.resources = template.resources;
            poam.estimatedEffort = template.estimatedEffort;
        }
        
        // Set standard fields
        poam.detectionSource = 'Vulnerability Scanning Tool';
        poam.status = poam.status || 'Open'; // Default to Open if not already set
        
        console.log(`ğŸ“‹ Applied enhanced template for ${poam.findingType || 'Unknown'} to POAM ${poam.id}`);
        console.log(`ğŸ”§ Generated mitigation: ${poam.mitigation.substring(0, 100)}...`);
        return poam;
    }
    
    // ... (rest of the code remains the same)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    async analyzeAndGroup(rawVulnerabilities, scanId = null) {
        console.log('\nğŸ” â•â•â• ENHANCED ANALYSIS ENGINE V3 STARTED â•â•â•');
        console.log(`ğŸ“Š Total raw vulnerabilities: ${rawVulnerabilities.length}`);
        if (scanId) {
            console.log(`ğŸ“¸ Scan ID: ${scanId}`);
        }
        
        this.vulnerabilities = rawVulnerabilities;
        this.scanId = scanId; // Store for later use
        this.debugCount = 0;
        this.poamsCreated = 0;
        this.poamsSkipped = 0;
        this.skipReasons = {};
        
        // Step 1: Normalize findings
        console.log('\nâš™ï¸  Step 1: Normalizing findings...');
        const normalized = this.normalizeFindings(rawVulnerabilities);
        console.log(`âœ… Normalized ${normalized.length} findings`);
        
        // Step 2: Calculate SLA breach status
        console.log('\nâš™ï¸  Step 2: Calculating SLA breach status...');
        const withSLA = this.calculateSLAStatus(normalized);
        console.log(`âœ… SLA status calculated for ${withSLA.length} findings`);
        
        // Step 3: Classify remediation
        console.log('\nâš™ï¸  Step 3: Classifying remediation strategies...');
        const classified = this.classifyRemediation(withSLA);
        console.log(`âœ… Classified ${classified.length} findings`);
        
        // Step 4: Group by remediation signature
        console.log('\nâš™ï¸  Step 4: Grouping by remediation signatures...');
        const groups = this.groupByRemediationSignature(classified);
        console.log(`âœ… Created ${groups.size} unique remediation groups`);
        
        // Step 5: Apply SLA gating and build POAMs
        console.log('\nâš™ï¸  Step 5: Applying SLA gating and building POAMs...');
        const poamsResult = await this.buildPOAMsWithSLAGating(groups);
        console.log('ğŸ” poamsResult from buildPOAMsWithSLAGating:', poamsResult);
        console.log('ğŸ” poamsResult type:', typeof poamsResult);
        console.log('ğŸ” poamsResult length:', poamsResult?.length || 'undefined');
        
        this.groupedPOAMs = poamsResult;
        console.log(`âœ… Created ${this.poamsCreated} POAMs (skipped ${this.poamsSkipped})`);
        
        // Step 6: Calculate confidence
        console.log('\nâš™ï¸  Step 6: Calculating confidence scores...');
        console.log('ğŸ” groupedPOAMs:', this.groupedPOAMs);
        console.log('ğŸ” groupedPOAMs length:', this.groupedPOAMs?.length || 'undefined');
        
        if (!this.groupedPOAMs || !Array.isArray(this.groupedPOAMs)) {
            console.error('âŒ groupedPOAMs is not defined or not an array, skipping confidence calculation');
            return this.groupedPOAMs || [];
        }
        
        this.calculatePOAMConfidence();
        console.log(`âœ… Confidence scoring complete`);
        
        // Step 7: Handle baseline comparison if not in baseline mode
        if (!this.isBaselineMode) {
            console.log('\nâš™ï¸  Step 7: Performing baseline comparison...');
            this.performBaselineComparison();
            console.log(`âœ… Baseline comparison complete`);
        }
        
        // Log skip reasons
        if (this.poamsSkipped > 0) {
            console.log('\nğŸ“‹ POAM Skip Reasons:');
            Object.entries(this.skipReasons).forEach(([reason, count]) => {
                console.log(`   ${reason}: ${count} groups`);
            });
        }
        
        console.log('\nğŸ¯ â•â•â• ANALYSIS COMPLETE â•â•â•\n');
        
        return this.groupedPOAMs;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SLA BREACH CALCULATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    calculateSLAStatus(findings) {
        const now = new Date();
        
        return findings.map(finding => {
            const firstDetected = this.parseDate(finding.firstDetected);
            const lastDetected = this.parseDate(finding.lastDetected);
            const status = finding.status || 'ACTIVE';
            const severity = this.normalizeSeverity(finding.severity || finding.risk);
            
            // Calculate age in days
            const ageDays = firstDetected ? this.daysBetween(firstDetected, now) : 0;
            
            // Get SLA days for this severity
            const slaDays = this.slaConfig[severity] || this.slaConfig.medium;
            
            // Determine if breached
            const breached = (status === 'ACTIVE' || status === 'NEW' || status === 'OPEN') && 
                           (ageDays > slaDays) && 
                           firstDetected !== null;
            
            // Calculate breach date
            const breachDate = firstDetected ? 
                this.addDays(firstDetected, slaDays) : null;
            
            return {
                ...finding,
                sla: {
                    severity,
                    slaDays,
                    ageDays,
                    breached,
                    breachDate: breachDate ? breachDate.toISOString().split('T')[0] : null,
                    firstDetected: firstDetected ? firstDetected.toISOString().split('T')[0] : null,
                    lastDetected: lastDetected ? lastDetected.toISOString().split('T')[0] : null,
                    status
                }
            };
        });
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ENHANCED POAM BUILDING WITH SLA GATING
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    async buildPOAMsWithSLAGating(groups) {
        const poams = [];
        // Ensure sequential numbering starting from 001
        let poamIdCounter = 1;
        
        for (const [signature, group] of groups) {
            const rem = group.remediation;
            
            // Calculate breach status for this group
            const breachAnalysis = this.analyzeGroupBreach(group);
            
            // SLA Gating: Only create POAM if group is breached
            if (!breachAnalysis.groupBreached) {
                this.poamsSkipped++;
                this.skipReasons[breachAnalysis.skipReason] = 
                    (this.skipReasons[breachAnalysis.skipReason] || 0) + 1;
                
                // Debug first 5 skipped groups
                if (this.poamsSkipped <= 5) {
                    console.log(`\nâ­ï¸  Skipped Group: ${signature.substring(0, 80)}`);
                    console.log(`   Reason: ${breachAnalysis.skipReason}`);
                    console.log(`   Active Assets: ${breachAnalysis.activeAssets.size}`);
                    console.log(`   Breached Assets: ${breachAnalysis.breachedAssets.size}`);
                }
                return; // Skip this group
            }
            
            // Assign POC using rules engine
            const pocAssignment = this.assignPOC(rem, group);
            
            // Legacy and Baseline Detection
            const firstDetectedDate = breachAnalysis.oldestDetectionDate;
            const isLegacy = isLegacyFinding(firstDetectedDate);
            const isRecent = isRecentFinding(firstDetectedDate);
            
            // Calculate due date based on legacy/recent status and baseline mode
            let calculatedDueDate;
            if (this.isBaselineMode) {
                // BASELINE IMPORT: All POAMs get fresh due dates from current date
                calculatedDueDate = calculateDueDateForLegacy(breachAnalysis.highestRisk, firstDetectedDate);
                console.log(`ğŸ“Š Baseline mode: POAM will get fresh due date from current date`);
            } else {
                // FUTURE SCANS: Use normal logic (legacy gets fresh date, recent uses detection date)
                if (isLegacy) {
                    calculatedDueDate = calculateDueDateForLegacy(breachAnalysis.highestRisk, firstDetectedDate);
                } else if (isRecent) {
                    calculatedDueDate = calculateDueDateForRecent(breachAnalysis.highestRisk, firstDetectedDate);
                } else {
                    // Standard due date calculation for normal findings
                    calculatedDueDate = breachAnalysis.oldestBreachDate;
                }
            }
            
            // Calculate days overdue
            const now = new Date();
            const breachDate = new Date(calculatedDueDate);
            const daysOverdue = this.daysBetween(breachDate, now);
            
            // Determine POAM status
            const poamStatus = this.determinePOAMStatus(rem, breachAnalysis, group);
            
            // Generate smart POAM description
            const description = this.generateSmartDescription(rem, group, breachAnalysis);
            
            // Select POAM title from scanner-provided titles (NOT generated)
            const poamTitle = this.selectPOAMTitle(rem, group, breachAnalysis);
            
            // Determine title rule used for debugging
            const titleRuleUsed = this.getTitleSelectionRule(rem, group);
            
            // Calculate all three asset counts
            const totalAffectedAssets = group.assets.size; // All assets with the finding
            const activeAssetCount = breachAnalysis.activeAssets.size; // Assets still detecting
            const breachedAssetCount = breachAnalysis.breachedAssets.size; // Assets out of SLA
            
            const poam = {
                // Database required fields
                id: `POAM-${String(poamIdCounter).padStart(4, '0')}`,
                
                // POAM source (MANDATORY)
                source: 'Vulnerability Scan Report',
                
                // Display fields
                title: poamTitle,
                description: description,
                
                // Remediation metadata
                remediationSignature: signature,
                remediationType: rem.remediationType,
                component: rem.component,
                platform: rem.platform,
                targetingStrategy: rem.targetingStrategy,
                fixedTarget: rem.fixedTarget,
                fixedTargetKey: rem.fixedTargetKey,
                actionText: rem.actionText,
                
                // Status and tracking
                status: poamStatus,
                risk: breachAnalysis.highestRisk,
                dueDate: calculatedDueDate,
                createdDate: new Date().toISOString().split('T')[0],
                
                // Legacy and Baseline Information
                isLegacy: isLegacy,
                isRecent: isRecent,
                firstDetectedDate: firstDetectedDate,
                baselineType: isLegacy ? 'Legacy' : (isRecent ? 'Recent' : 'Standard'),
                
                // Priority fields for display and sorting
                daysOverdue: daysOverdue,
                breachedAssetCount: breachedAssetCount,
                
                // SLA and breach metadata
                slaBreached: true,
                slaDays: breachAnalysis.slaDays,
                oldestDetectionDate: breachAnalysis.oldestDetectionDate,
                breachDate: breachAnalysis.oldestBreachDate,
                
                // Asset counts (THREE COUNTS - CRITICAL)
                totalAffectedAssets: totalAffectedAssets,      // All assets with the finding
                activeAssets: activeAssetCount,                 // Assets still detecting
                breachedAssets: breachedAssetCount,            // Assets out of SLA
                assetCount: totalAffectedAssets,               // For UI list view display
                assetCountBreached: breachedAssetCount,        // For SLA compliance
                assetCountActive: activeAssetCount,            // For detail view
                assetCountWithinSLA: breachAnalysis.withinSlaAssets.size,
                findingCount: group.findings.length,
                
                // Aggregated data
                affectedAssets: Array.from(group.assets),      // All affected assets
                asset: Array.from(group.assets).join(', '),    // For database index
                breachedAssetsList: Array.from(breachAnalysis.breachedAssets),
                activeAssetsList: Array.from(breachAnalysis.activeAssets),
                withinSlaAssets: Array.from(breachAnalysis.withinSlaAssets),
                cves: Array.from(group.cves),
                qids: Array.from(group.qids),
                advisoryIds: Array.from(group.advisoryIds),
                
                // POC assignment
                poc: pocAssignment.pocTeam,
                pocTeam: pocAssignment.pocTeam,
                assignmentReason: pocAssignment.assignmentReason,
                recommendedOwner: pocAssignment.pocTeam,
                
                // Evidence
                evidenceSamples: group.evidenceSamples,
                
                // Confidence (will be calculated in step 6)
                confidenceScore: 0,
                needsReview: false,
                
                // Debug metadata
                debugInfo: {
                    whyPOAMCreated: `SLA breached: ${breachAnalysis.breachedAssets.size} assets exceeded ${breachAnalysis.slaDays}-day SLA for ${breachAnalysis.highestRisk} severity (oldest detection: ${breachAnalysis.oldestDetectionDate}, breach date: ${breachAnalysis.oldestBreachDate}, ${daysOverdue} days overdue)`,
                    whyPOAMSkipped: null,
                    titleRuleUsed: titleRuleUsed,
                    remediationType: rem.remediationType,
                    firstDetectedOldest: breachAnalysis.oldestDetectionDate,
                    daysOverdue: daysOverdue,
                    pocAssignmentRule: pocAssignment.ruleMatched,
                    pocAssignmentPrecedence: pocAssignment.precedence,
                    breachAnalysis: {
                        breachedCount: breachAnalysis.breachedAssets.size,
                        activeCount: breachAnalysis.activeAssets.size,
                        withinSlaCount: breachAnalysis.withinSlaAssets.size,
                        oldestAge: breachAnalysis.oldestAge,
                        slaDays: breachAnalysis.slaDays
                    }
                },
                
                // Raw findings for drill-down
                rawFindings: group.findings
            };
            
            // Apply POAM template for automatic field population
            const findingType = this.determineFindingType(group.findings[0], rem);
            const enhancedPOAM = this.applyPOAMTemplate(poam, findingType, group.findings[0], rem, group);
            
            // Create PoamScanSummary if we have a scanId
            if (this.scanId) {
                try {
                    const scanSummary = this.createScanSummary(poam.id, group, rem);
                    await this.saveScanSummary(scanSummary);
                    
                    // Link POAM to latest scan
                    enhancedPOAM.latestScanId = this.scanId;
                    enhancedPOAM.latestSummaryId = scanSummary.id;
                } catch (error) {
                    console.error(`âŒ Failed to create scan summary for POAM ${poam.id}:`, error);
                    // Continue without scan summary - POAM will still be created
                }
            }
            
            poams.push(enhancedPOAM);
            this.poamsCreated++;
            poamIdCounter++;
            
            // Debug first 5 created POAMs
            if (this.poamsCreated <= 5) {
                console.log(`\nâœ… Created POAM #${this.poamsCreated}: ${poamTitle.substring(0, 80)}`);
                console.log(`   POC: ${pocAssignment.pocTeam} (${pocAssignment.assignmentReason})`);
                console.log(`   Breached Assets: ${breachAnalysis.breachedAssets.size}`);
                console.log(`   Due Date: ${calculatedDueDate}`);
                console.log(`   Confidence: Will be calculated`);
            }
        }
        
        console.log(`ğŸ” buildPOAMsWithSLAGating returning ${poams.length} POAMs`);
        console.log('ğŸ” POAMs array:', poams);
        return poams;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // BREACH ANALYSIS FOR GROUP
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    analyzeGroupBreach(group) {
        const breachedAssets = new Set();
        const activeAssets = new Set();
        const withinSlaAssets = new Set();
        
        let oldestDetectionDate = null;
        let oldestBreachDate = null;
        let oldestAge = 0;
        let highestRisk = 'low';
        let slaDays = 90;
        
        group.findings.forEach(finding => {
            const asset = finding.asset?.hostname || finding.asset?.assetId || 'unknown';
            const sla = finding.sla;
            
            if (!sla) return;
            
            // Track active assets
            if (sla.status === 'ACTIVE' || sla.status === 'NEW' || sla.status === 'OPEN') {
                activeAssets.add(asset);
                
                // Track breached vs within SLA
                if (sla.breached) {
                    breachedAssets.add(asset);
                    
                    // Track oldest detection
                    const detectionDate = new Date(sla.firstDetected);
                    if (!oldestDetectionDate || detectionDate < oldestDetectionDate) {
                        oldestDetectionDate = detectionDate;
                        oldestBreachDate = sla.breachDate;
                        oldestAge = sla.ageDays;
                        slaDays = sla.slaDays;
                    }
                } else {
                    withinSlaAssets.add(asset);
                }
            }
            
            // Track highest risk
            if (this.isHigherRisk(sla.severity, highestRisk)) {
                highestRisk = sla.severity;
            }
        });
        
        // Determine if group is breached
        const groupBreached = breachedAssets.size > 0;
        
        // Determine skip reason if not breached
        let skipReason = null;
        if (!groupBreached) {
            if (activeAssets.size === 0) {
                skipReason = 'No active findings (all fixed or closed)';
            } else if (withinSlaAssets.size > 0) {
                skipReason = 'All active findings within SLA';
            } else {
                skipReason = 'Missing detection dates';
            }
        }
        
        return {
            groupBreached,
            breachedAssets,
            activeAssets,
            withinSlaAssets,
            oldestDetectionDate: oldestDetectionDate ? oldestDetectionDate.toISOString().split('T')[0] : null,
            oldestBreachDate,
            oldestAge,
            highestRisk,
            slaDays,
            skipReason
        };
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ENHANCED CONFIDENCE SCORING (OVERRIDE)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    calculatePOAMConfidence() {
        if (!this.groupedPOAMs || !Array.isArray(this.groupedPOAMs)) {
            console.error('âŒ calculatePOAMConfidence: groupedPOAMs is not defined or not an array');
            return;
        }
        
        console.log(`ğŸ” Calculating confidence for ${this.groupedPOAMs.length} POAMs`);
        this.groupedPOAMs.forEach(poam => {
            let score = 0;
            let maxScore = 0;
            const reviewReasons = [];
            
            // Advisory ID extracted (+40)
            maxScore += 40;
            if (poam.advisoryIds.length > 0) {
                score += 40;
            } else {
                reviewReasons.push('No advisory IDs extracted');
            }
            
            // Fixed target extracted (+30)
            maxScore += 30;
            if (poam.fixedTarget && poam.fixedTargetKey !== 'unknown') {
                score += 30;
            } else {
                reviewReasons.push('Fixed target not clearly identified');
            }
            
            // Remediation type confidently classified (+20)
            maxScore += 20;
            if (poam.remediationType !== 'unknown' && poam.remediationType !== 'no_action_unknown') {
                score += 20;
            } else {
                reviewReasons.push('Remediation type unclear');
            }
            
            // Component dictionary match (+15)
            maxScore += 15;
            if (this.componentDictionary[poam.component.toLowerCase()]) {
                score += 15;
            } else {
                reviewReasons.push('Component not in known dictionary');
            }
            
            // Current evidence extracted (+10)
            maxScore += 10;
            if (poam.evidenceSamples.length > 0) {
                score += 10;
            } else {
                reviewReasons.push('No evidence samples available');
            }
            
            // Calculate final score
            poam.confidenceScore = Math.round((score / maxScore) * 100);
            
            // Determine confidence level
            if (poam.confidenceScore >= 80) {
                poam.confidenceLevel = 'High';
            } else if (poam.confidenceScore >= 60) {
                poam.confidenceLevel = 'Medium';
            } else {
                poam.confidenceLevel = 'Low';
            }
            
            // Enhanced needsReview logic
            let needsReview = false;
            
            // Rule 1: Confidence score < 70
            if (poam.confidenceScore < 70) {
                needsReview = true;
                if (!reviewReasons.includes('Low confidence score')) {
                    reviewReasons.push('Low confidence score');
                }
            }
            
            // Rule 2: Windows patch cycle missing
            if (poam.remediationType === 'patch_cycle' && 
                poam.platform === 'windows' && 
                !poam.fixedTarget?.patchCycle) {
                needsReview = true;
                reviewReasons.push('Windows patch cycle date not detected');
            }
            
            // Rule 3: Conflicting fixed targets detected
            if (this.hasConflictingTargets(poam)) {
                needsReview = true;
                reviewReasons.push('Conflicting fixed targets detected in findings');
            }
            
            // Rule 4: Unassigned POC
            if (poam.pocTeam === 'Unassigned') {
                needsReview = true;
                reviewReasons.push('No POC team assigned');
            }
            
            poam.needsReview = needsReview;
            poam.reviewReasons = reviewReasons;
        });
    }
    
    hasConflictingTargets(poam) {
        // Check if raw findings have significantly different fixed targets
        if (!poam.rawFindings || poam.rawFindings.length < 2) return false;
        
        const targets = new Set();
        poam.rawFindings.forEach(f => {
            const target = f.remediation?.fixedTarget?.version || 
                          f.remediation?.fixedTarget?.patchCycle ||
                          f.remediation?.fixedTargetKey;
            if (target && target !== 'unknown' && target !== 'latest') {
                targets.add(target);
            }
        });
        
        // If more than 2 different specific targets, flag as conflicting
        return targets.size > 2;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // POC ASSIGNMENT RULES ENGINE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    assignPOC(remediation, group) {
        // Precedence: 1) Asset tags, 2) Platform, 3) Component class, 4) Fallback
        
        // 1) Check for explicit asset tags or boundary ownership (highest priority)
        const assetTagMatch = this.checkAssetTagRules(group.findings);
        if (assetTagMatch) {
            return {
                pocTeam: assetTagMatch.team,
                assignmentReason: `asset_tag=${assetTagMatch.tag}`,
                ruleMatched: 'Asset Tag Rule',
                precedence: 1
            };
        }
        
        // 2) Platform-based assignment
        const platformMatch = this.checkPlatformRules(remediation);
        if (platformMatch) {
            return {
                pocTeam: platformMatch.team,
                assignmentReason: `platform=${remediation.platform}`,
                ruleMatched: 'Platform Rule',
                precedence: 2
            };
        }
        
        // 3) Component class assignment
        const componentMatch = this.checkComponentRules(remediation);
        if (componentMatch) {
            return {
                pocTeam: componentMatch.team,
                assignmentReason: `component=${remediation.component}`,
                ruleMatched: 'Component Rule',
                precedence: 3
            };
        }
        
        // 4) Fallback - flag as unassigned priority
        return {
            pocTeam: 'Unassigned',
            assignmentReason: 'no_matching_rule',
            ruleMatched: 'Fallback',
            precedence: 99,
            flagAsPriority: true
        };
    }
    
    checkAssetTagRules(findings) {
        // Check for asset tags in findings
        for (const finding of findings.slice(0, 10)) {
            const tags = finding.assetTags || finding.asset?.assetTags || '';
            const tagsLower = tags.toLowerCase();
            
            if (tagsLower.includes('dmz') || tagsLower.includes('boundary')) {
                return { team: 'Network Security Team', tag: 'DMZ/Boundary' };
            }
            if (tagsLower.includes('pci') || tagsLower.includes('cardholder')) {
                return { team: 'PCI Compliance Team', tag: 'PCI' };
            }
            if (tagsLower.includes('critical') || tagsLower.includes('tier1')) {
                return { team: 'Critical Systems Team', tag: 'Critical/Tier1' };
            }
        }
        return null;
    }
    
    checkPlatformRules(remediation) {
        const platform = remediation.platform;
        const component = remediation.component;
        
        // Windows endpoint vs server distinction
        if (platform === 'windows') {
            // Check if it's endpoint software (browsers, etc.)
            if (['firefox', 'chrome', 'edge', 'safari'].includes(component)) {
                return { team: 'End User Computing Team' };
            }
            // Server components
            return { team: 'Windows Systems Team' };
        }
        
        if (platform === 'linux') {
            return { team: 'Linux Systems Team' };
        }
        
        if (platform === 'network') {
            return { team: 'Network Engineering Team' };
        }
        
        return null;
    }
    
    checkComponentRules(remediation) {
        const component = remediation.component;
        
        // Browsers
        if (['firefox', 'chrome', 'edge', 'safari'].includes(component)) {
            return { team: 'Desktop Engineering Team' };
        }
        
        // Application frameworks
        if (['java', 'dotnet', 'python', 'nodejs', 'spring_framework'].includes(component)) {
            return { team: 'Application Development Team' };
        }
        
        // Web servers
        if (['apache', 'nginx', 'iis', 'tomcat'].includes(component)) {
            return { team: 'Web Infrastructure Team' };
        }
        
        // Network/security components
        if (['openssh', 'ssl', 'tls'].includes(component)) {
            return { team: 'Network Security Team' };
        }
        
        return null;
    }
    
    evaluateRuleConditions(conditions, remediation, group) {
        if (!conditions || Object.keys(conditions).length === 0) return false;
        
        let matches = true;
        
        if (conditions.platform) {
            matches = matches && conditions.platform.includes(remediation.platform);
        }
        if (conditions.remediationType) {
            matches = matches && conditions.remediationType.includes(remediation.remediationType);
        }
        if (conditions.component) {
            matches = matches && conditions.component.includes(remediation.component);
        }
        
        return matches;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SMART POAM DESCRIPTIONS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    generateSmartDescription(remediation, group, breachAnalysis) {
        console.log('ğŸ“ Generating simplified description using raw vulnerability data');
        console.log('ğŸ” Group data:', group);
        console.log('ğŸ” First finding raw data:', group.findings[0]);
        
        // Get the raw vulnerability description from the first finding
        const firstFinding = group.findings[0];
        console.log('ğŸ” Available fields in firstFinding:', Object.keys(firstFinding));
        console.log('ğŸ” First finding description:', firstFinding.description);
        console.log('ğŸ” First finding title:', firstFinding.title);
        console.log('ğŸ” First finding cve:', firstFinding.cve);
        console.log('ğŸ” First finding vulnerability:', firstFinding.vulnerability);
        console.log('ğŸ” First finding results:', firstFinding.results);
        console.log('ğŸ” First finding QID:', firstFinding.QID);
        console.log('ğŸ” First finding full raw data:', firstFinding);
        
        const rawDescription = firstFinding.description || firstFinding.title || 'Vulnerability detected on affected assets';
        console.log('ğŸ” Using rawDescription:', rawDescription);
        
        // Build simple description with raw data and essential information (NO affected assets)
        let description = rawDescription;
        
        // Add CVEs for reference
        const cves = this.extractAllCVEs(group.findings);
        console.log('ğŸ” Extracted CVEs:', cves);
        if (cves.length > 0) {
            description += `\n\nRelated CVEs:\n${cves.join(', ')}`;
        }
        
        // Add NIST control references
        const controls = this.extractNISTControls(remediation);
        console.log('ğŸ” Extracted NIST controls:', controls);
        if (controls.length > 0) {
            description += `\n\nNIST Controls:\n${controls.join(', ')}`;
        }
        
        console.log('ğŸ” Final generated description (no assets):', description);
        return description;
    }
    
    // Separate function to get affected assets for the dedicated tab/section
    getAffectedAssetsForDisplay(group) {
        console.log('ğŸ¢ Extracting affected assets for dedicated display');
        const affectedAssets = this.extractAffectedAssets(group.findings);
        console.log('ğŸ” Affected assets for display:', affectedAssets);
        return affectedAssets;
    }
    
    extractAffectedAssets(findings) {
        const assets = new Set();
        findings.forEach(finding => {
            if (finding.asset) assets.add(finding.asset);
            if (finding.host) assets.add(finding.host);
            if (finding.ip && finding.ip !== 'N/A') {
                assets.add(`${finding.ip} (${finding.asset || finding.host || 'Unknown'})`);
            }
        });
        return Array.from(assets).slice(0, 10); // Limit to first 10 assets
    }
    
    extractAllCVEs(findings) {
        const cves = new Set();
        findings.forEach(finding => {
            if (finding.cve) {
                // Handle multiple CVEs separated by commas
                const cveList = finding.cve.split(',').map(cve => cve.trim());
                cveList.forEach(cve => {
                    if (cve.startsWith('CVE-')) {
                        cves.add(cve);
                    }
                });
            }
        });
        return Array.from(cves);
    }
    
    extractNISTControls(remediation) {
        const controls = [];
        if (remediation.impactedControls) {
            controls.push(...remediation.impactedControls);
        }
        return controls;
    }
    
    generateDescriptionSummary(remediation, componentTitle, group) {
        switch (remediation.remediationType) {
            case 'patch_cycle':
                if (remediation.platform === 'windows' && remediation.fixedTarget?.patchCycle) {
                    return `Windows ${remediation.fixedTarget.patchCycle} Security Updates are missing on the affected assets.`;
                }
                return `${componentTitle} security updates are missing on the affected assets.`;
                
            case 'kb_install':
                const kbIds = remediation.fixedTarget?.kbIds?.join(', ') || 'KB updates';
                return `Windows ${kbIds} are missing on the affected assets.`;
                
            case 'software_upgrade':
                if (remediation.targetingStrategy === 'latest_supported') {
                    return `${componentTitle} is below the approved latest release on the affected assets, resulting in multiple vulnerabilities.`;
                } else {
                    const targetVersion = remediation.fixedTarget?.version || remediation.fixedTargetKey;
                    return `${componentTitle} requires upgrade to version ${targetVersion} on the affected assets to address multiple vulnerabilities.`;
                }
                
            case 'vendor_fix':
                return `${componentTitle} requires vendor-provided security fix on the affected assets.`;
                
            case 'config_change':
                return `${componentTitle} configuration hardening is required on the affected assets.`;
                
            case 'operational_mitigation':
                return `${componentTitle} requires operational mitigation controls as no vendor patch is available.`;
                
            case 'package_upgrade':
                return `${componentTitle} package requires update on the affected assets.`;
                
            default:
                return `${componentTitle} requires remediation on the affected assets.`;
        }
    }
    
    generateRemediationAction(remediation, componentTitle, group) {
        switch (remediation.remediationType) {
            case 'patch_cycle':
                if (remediation.platform === 'windows' && remediation.fixedTarget?.patchCycle) {
                    return `Deploy the Windows ${remediation.fixedTarget.patchCycle} cumulative security updates to all affected assets using the standard Windows patch deployment process (WSUS/SCCM/Intune).`;
                }
                return `Deploy the latest security patches to all affected ${remediation.platform} systems using the standard patch management process.`;
                
            case 'kb_install':
                const kbIds = remediation.fixedTarget?.kbIds?.join(', ') || 'the required KB updates';
                return `Install ${kbIds} on all affected Windows systems using the standard Windows update deployment process.`;
                
            case 'software_upgrade':
                if (remediation.targetingStrategy === 'latest_supported') {
                    return `Upgrade ${componentTitle} to the approved latest release using the standard endpoint deployment process. Verify the approved version with the Change Advisory Board before deployment.`;
                } else {
                    const targetVersion = remediation.fixedTarget?.version || remediation.fixedTargetKey;
                    return `Upgrade ${componentTitle} to version ${targetVersion} or later using the standard application deployment process.`;
                }
                
            case 'vendor_fix':
                const advisory = Array.from(group.advisoryIds)[0] || 'vendor advisory';
                return `Apply the vendor-provided security fix per ${advisory} documentation. Follow vendor-specific installation procedures.`;
                
            case 'config_change':
                return `Apply the recommended configuration hardening per organizational security baseline. Document configuration changes in the change management system.`;
                
            case 'operational_mitigation':
                return `Implement compensating controls including: network segmentation to limit exposure, access restrictions via firewall rules or ACLs, enhanced monitoring and alerting for exploitation attempts. Document mitigation controls and monitor for vendor patch availability.`;
                
            case 'package_upgrade':
                const targetVersion = remediation.fixedTarget?.version || 'latest';
                return `Update ${componentTitle} package to version ${targetVersion} using the system package manager (yum/apt/dnf). Test in non-production environment before production deployment.`;
                
            default:
                return `Remediate ${componentTitle} vulnerabilities per vendor guidance and organizational security standards.`;
        }
    }
    
    generateValidationMethod(remediation, componentTitle) {
        switch (remediation.remediationType) {
            case 'patch_cycle':
            case 'kb_install':
            case 'software_upgrade':
            case 'package_upgrade':
                return `Validation will be performed by rescanning affected assets using the vulnerability scanner and confirming that ${componentTitle} findings are resolved. Verify that the installed version meets or exceeds the required version.`;
                
            case 'vendor_fix':
                return `Validation will be performed by rescanning affected assets and confirming that the vendor advisory findings are cleared. Verify fix installation through system evidence (installed packages, version checks).`;
                
            case 'config_change':
                return `Validation will be performed by rescanning affected assets and confirming that configuration findings are resolved. Verify configuration changes through system audits and compliance scans.`;
                
            case 'operational_mitigation':
                return `Validation will be performed by verifying that compensating controls are in place and effective. Document control implementation and maintain monitoring for vendor patch availability. Rescan to confirm no new exploitation attempts.`;
                
            default:
                return `Validation will be performed by rescanning affected assets and confirming that findings are resolved.`;
        }
    }
    
    getLatestDetectionDate(findings) {
        let latest = null;
        findings.forEach(f => {
            const lastDetected = f.sla?.lastDetected;
            if (lastDetected) {
                if (!latest || lastDetected > latest) {
                    latest = lastDetected;
                }
            }
        });
        return latest || 'Unknown';
    }
    
    getDescriptionTemplate(remediation) {
        const templateKey = remediation.remediationType === 'software_upgrade' ?
            (remediation.targetingStrategy === 'latest_supported' ? 
                'software_upgrade_latest' : 'software_upgrade_branched') :
            remediation.remediationType;
        
        const templates = {
            patch_cycle: "Apply {platform} security patches for {patchCycle}.\n\nAffected Systems: {assetCount} assets\nSeverity: {severity}\nFirst Detected: {firstDetected}\nSLA Breach Date: {breachDate}\n\nThis POAM consolidates {findingCount} findings that require the {patchCycle} patch cycle to be applied.\n\nSample CVEs: {sampleCVEs}\nSample Advisories: {sampleAdvisories}\n\nRemediation Action: Deploy {patchCycle} patches to all affected {platform} systems.",
            
            kb_install: "Install KB updates for {component}.\n\nAffected Systems: {assetCount} assets\nSeverity: {severity}\nKB Updates Required: {kbIds}\nFirst Detected: {firstDetected}\nSLA Breach Date: {breachDate}\n\nThis POAM consolidates {findingCount} findings requiring KB installation.\n\nSample CVEs: {sampleCVEs}\n\nRemediation Action: Install the following KB updates: {kbIds}",
            
            software_upgrade_latest: "Upgrade {component} to approved latest version on {platform} systems.\n\nAffected Systems: {assetCount} assets\nSeverity: {severity}\nCurrent Versions Detected: {currentVersions}\nTarget: Latest approved version\nFirst Detected: {firstDetected}\nSLA Breach Date: {breachDate}\n\nThis POAM consolidates {findingCount} findings across multiple CVEs that are all resolved by upgrading {component} to the latest approved version.\n\nSample CVEs: {sampleCVEs}\nSample Advisories: {sampleAdvisories}\n\nRemediation Action: Upgrade all instances of {component} to the latest approved version per organizational standards.",
            
            software_upgrade_branched: "Upgrade {component} to version {targetVersion} on {platform} systems.\n\nAffected Systems: {assetCount} assets\nSeverity: {severity}\nCurrent Versions Detected: {currentVersions}\nTarget Version: {targetVersion}\nFirst Detected: {firstDetected}\nSLA Breach Date: {breachDate}\n\nThis POAM consolidates {findingCount} findings for {component} version {majorVersion} track.\n\nSample CVEs: {sampleCVEs}\n\nRemediation Action: Upgrade {component} to version {targetVersion} or later within the {majorVersion} support track.",
            
            vendor_fix: "Apply vendor security fix per advisory {advisoryIds}.\n\nAffected Systems: {assetCount} assets\nSeverity: {severity}\nComponent: {component}\nAdvisory IDs: {advisoryIds}\nFirst Detected: {firstDetected}\nSLA Breach Date: {breachDate}\n\nThis POAM consolidates {findingCount} findings addressed by vendor advisory {advisoryIds}.\n\nSample CVEs: {sampleCVEs}\n\nRemediation Action: Apply vendor-provided fix per advisory documentation.",
            
            operational_mitigation: "Implement operational mitigation for {component} (no patch available).\n\nAffected Systems: {assetCount} assets\nSeverity: {severity}\nComponent: {component}\nFirst Detected: {firstDetected}\nSLA Breach Date: {breachDate}\n\nThis POAM consolidates {findingCount} findings with no vendor patch available.\n\nSample CVEs: {sampleCVEs}\n\nRemediation Action: Implement compensating controls such as network segmentation, access restrictions, or monitoring until vendor provides a patch.\n\nEvidence Samples:\n{evidenceSamples}",
            
            package_upgrade: "Update {component} package to version {targetVersion} on {platform} systems.\n\nAffected Systems: {assetCount} assets\nSeverity: {severity}\nCurrent Versions: {currentVersions}\nTarget Version: {targetVersion}\nFirst Detected: {firstDetected}\nSLA Breach Date: {breachDate}\n\nThis POAM consolidates {findingCount} findings for {component} package updates.\n\nSample CVEs: {sampleCVEs}\n\nRemediation Action: Update {component} package using system package manager (yum/apt/dnf)."
        };
        
        return templates[templateKey] || templates.software_upgrade_latest;
    }
    
    selectPOAMTitle(remediation, group, breachAnalysis) {
        // CRITICAL: Titles MUST come from scanner-provided vulnerability titles
        // Do NOT generate synthetic remediation prose
        
        const titles = group.findings.map(f => f.text?.title || '').filter(t => t);
        
        if (titles.length === 0) {
            return 'Unknown Vulnerability (No title provided by scanner)';
        }
        
        // Rule 1: If all findings share the same exact title, use it verbatim
        const uniqueTitles = [...new Set(titles)];
        if (uniqueTitles.length === 1) {
            return uniqueTitles[0];
        }
        
        // Rule 2: For latest_supported components, use dominant common prefix
        if (remediation.targetingStrategy === 'latest_supported') {
            const commonPrefix = this.findCommonPrefix(titles);
            if (commonPrefix && commonPrefix.length > 10) {
                // Use common prefix with "Multiple Vulnerabilities" suffix
                return `${commonPrefix.trim()} Multiple Vulnerabilities`;
            }
        }
        
        // Rule 3: Windows patch cycle - retain exact month-based titles
        if (remediation.remediationType === 'patch_cycle' && remediation.platform === 'windows') {
            // Look for month/year pattern in titles
            const patchTitle = titles.find(t => t.match(/\b(20\d{2})[-\s](0[1-9]|1[0-2])\b/) || 
                                                  t.match(/\b(January|February|March|April|May|June|July|August|September|October|November|December)\s+(20\d{2})\b/i));
            if (patchTitle) {
                return patchTitle;
            }
            // Fallback: use most common title
            return this.getMostCommonTitle(titles);
        }
        
        // Rule 4: Configuration and exposure findings - retain exact scanner titles
        if (remediation.remediationType === 'config_change' || 
            remediation.remediationType === 'operational_mitigation') {
            // Use the most common title (likely the canonical one)
            return this.getMostCommonTitle(titles);
        }
        
        // Rule 5: For other cases, use most common title
        return this.getMostCommonTitle(titles);
    }
    
    findCommonPrefix(titles) {
        if (titles.length === 0) return '';
        if (titles.length === 1) return titles[0];
        
        // Find longest common prefix
        let prefix = titles[0];
        for (let i = 1; i < titles.length; i++) {
            while (titles[i].indexOf(prefix) !== 0) {
                prefix = prefix.substring(0, prefix.length - 1);
                if (prefix === '') return '';
            }
        }
        
        // Trim to last complete word
        const lastSpace = prefix.lastIndexOf(' ');
        if (lastSpace > 0) {
            prefix = prefix.substring(0, lastSpace);
        }
        
        return prefix;
    }
    
    getMostCommonTitle(titles) {
        // Count occurrences of each title
        const counts = {};
        titles.forEach(title => {
            counts[title] = (counts[title] || 0) + 1;
        });
        
        // Return most common
        let maxCount = 0;
        let mostCommon = titles[0];
        Object.entries(counts).forEach(([title, count]) => {
            if (count > maxCount) {
                maxCount = count;
                mostCommon = title;
            }
        });
        
        return mostCommon;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // HELPER FUNCTIONS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    parseDate(dateString) {
        if (!dateString) return null;
        const date = new Date(dateString);
        return isNaN(date.getTime()) ? null : date;
    }
    
    daysBetween(date1, date2) {
        const msPerDay = 1000 * 60 * 60 * 24;
        return Math.floor((date2 - date1) / msPerDay);
    }
    
    addDays(date, days) {
        const result = new Date(date);
        result.setDate(result.getDate() + days);
        return result;
    }
    
    normalizeSeverity(severity) {
        if (!severity) return 'medium';
        const sev = severity.toLowerCase();
        if (sev.includes('critical') || sev === '5') return 'critical';
        if (sev.includes('high') || sev === '4') return 'high';
        if (sev.includes('medium') || sev === '3') return 'medium';
        if (sev.includes('low') || sev === '2' || sev === '1') return 'low';
        return 'medium';
    }
    
    isHigherRisk(risk1, risk2) {
        const levels = { critical: 4, high: 3, medium: 2, low: 1 };
        return (levels[risk1] || 0) > (levels[risk2] || 0);
    }
    
    extractUniqueVersions(findings) {
        const versions = new Set();
        findings.forEach(f => {
            if (f.evidence?.currentVersion) {
                versions.add(f.evidence.currentVersion);
            }
        });
        return Array.from(versions).slice(0, 5);
    }
    
    determinePOAMStatus(remediation, breachAnalysis, group) {
        // POAM status logic:
        // - Open: breachedAssets exist and activeAssets exist
        // - Closed: no activeAssets remain
        // - Mitigation: remediationType == operational_mitigation
        // - Risk Accepted: remediationType == risk_acceptance OR CSV status = "yes"
        
        // Check CSV status field (Column V) - if any finding has status "yes", set to risk-accepted
        if (group && group.findings) {
            const hasRiskAcceptedStatus = group.findings.some(finding => {
                const status = (finding.status || '').toLowerCase().trim();
                return status === 'yes' || status === 'risk accepted' || status === 'risk-accepted';
            });
            
            if (hasRiskAcceptedStatus) {
                console.log(`ğŸ” Risk-accepted status detected in CSV for group with ${group.findings.length} findings`);
                return 'risk-accepted';
            }
        }
        
        if (remediation.remediationType === 'operational_mitigation') {
            return 'mitigation';
        }
        
        if (remediation.remediationType === 'risk_acceptance') {
            return 'risk_accepted';
        }
        
        if (breachAnalysis.activeAssets.size === 0) {
            return 'closed';
        }
        
        return 'open';
    }
    
    getTitleSelectionRule(remediation, group) {
        // Return which title SELECTION rule was used for debugging
        const titles = group.findings.map(f => f.text?.title || '').filter(t => t);
        const uniqueTitles = [...new Set(titles)];
        
        if (titles.length === 0) {
            return 'No scanner titles available';
        }
        
        if (uniqueTitles.length === 1) {
            return 'Single exact title (used verbatim)';
        }
        
        if (remediation.targetingStrategy === 'latest_supported') {
            return 'Latest-supported component (common prefix + Multiple Vulnerabilities)';
        }
        
        if (remediation.remediationType === 'patch_cycle' && remediation.platform === 'windows') {
            return 'Windows patch cycle (month-based title from scanner)';
        }
        
        if (remediation.remediationType === 'config_change' || 
            remediation.remediationType === 'operational_mitigation') {
            return 'Configuration/mitigation (most common scanner title)';
        }
        
        return 'Most common scanner title selected';
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SCAN SUMMARY CREATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    createScanSummary(poamId, group, remediation) {
        console.log(`ğŸ“¸ Creating scan summary for POAM ${poamId}`);
        
        // Extract affected assets from raw findings
        const affectedAssets = [];
        const assetSet = new Set();
        
        group.findings.forEach(finding => {
            // Try different Qualys asset field names
            if (finding.host) assetSet.add(finding.host);
            if (finding.asset) assetSet.add(finding.asset);
            if (finding['dns name']) assetSet.add(finding['dns name']);
            if (finding.ip && finding.ip !== 'N/A') {
                const hostname = finding.host || finding.asset || finding['dns name'] || 'Unknown';
                assetSet.add(`${finding.ip} (${hostname})`);
            }
        });
        
        affectedAssets.push(...Array.from(assetSet).slice(0, 50)); // Limit to 50 for performance
        
        // Extract solution text (most common or first non-empty)
        const solutions = group.findings
            .map(f => f.solution || f.remediation || f['solution recommendation'])
            .filter(s => s && s.trim() !== '');
        const solutionText = solutions.length > 0 ? 
            this.getMostCommonValue(solutions) : solutions[0] || '';
        
        // Extract sample results for audit evidence
        const results = group.findings
            .map(f => f.results || f.result || f.description || f.title)
            .filter(r => r && r.trim() !== '');
        const resultsSamples = results.slice(0, 3); // Take first 3 samples
        
        // Extract detection dates if available
        const dates = group.findings
            .map(f => f['first detected'] || f['last detected'] || f.date || f.detected)
            .filter(d => d && d.trim() !== '');
        
        let firstDetectedMin = null;
        let lastDetectedMax = null;
        
        if (dates.length > 0) {
            const parsedDates = dates
                .map(d => new Date(d))
                .filter(d => !isNaN(d.getTime()));
            
            if (parsedDates.length > 0) {
                firstDetectedMin = new Date(Math.min(...parsedDates)).toISOString();
                lastDetectedMax = new Date(Math.max(...parsedDates)).toISOString();
            }
        }
        
        const scanSummary = {
            poamId: poamId,
            scanId: this.scanId,
            rawFindings: group.findings, // Store raw findings for this POAM
            affectedAssets: affectedAssets,
            totalAffectedAssets: affectedAssets.length,
            firstDetectedMin: firstDetectedMin,
            lastDetectedMax: lastDetectedMax,
            solutionText: solutionText,
            resultsSamples: resultsSamples,
            createdAt: new Date().toISOString()
        };
        
        console.log(`âœ… Created scan summary for ${poamId}: ${affectedAssets.length} assets, ${resultsSamples.length} result samples`);
        return scanSummary;
    }

    async saveScanSummary(scanSummary) {
        try {
            await poamDB.savePoamScanSummary(scanSummary);
            console.log(`ğŸ’¾ Saved scan summary for POAM ${scanSummary.poamId}`);
        } catch (error) {
            console.error(`âŒ Failed to save scan summary for POAM ${scanSummary.poamId}:`, error);
        }
    }

    getMostCommonValue(arr) {
        const frequency = {};
        let maxCount = 0;
        let mostCommon = arr[0];
        
        arr.forEach(item => {
            frequency[item] = (frequency[item] || 0) + 1;
            if (frequency[item] > maxCount) {
                maxCount = frequency[item];
                mostCommon = item;
            }
        });
        
        return mostCommon;
    }
}

// Export for use
if (typeof module !== 'undefined' && module.exports) {
    module.exports = VulnerabilityAnalysisEngineV3;
}
