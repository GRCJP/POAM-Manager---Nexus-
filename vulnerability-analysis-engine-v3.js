// Enhanced Vulnerability Analysis Engine V3
// Adds SLA Gating, POC Assignment Rules, and Smart POAM Descriptions

console.log('‚úÖ vulnerability-analysis-engine-v3.js loaded successfully');

class VulnerabilityAnalysisEngineV3 extends VulnerabilityAnalysisEngineV2 {
    constructor() {
        super();
        
        // SLA Configuration (days by severity)
        this.slaConfig = {
            critical: 30,
            high: 60,
            medium: 90,
            low: 180
        };
        
        // POC Assignment Rules (priority-based)
        this.pocRules = [
            {
                name: "Windows Systems Team",
                priority: 1,
                conditions: {
                    platform: ["windows"],
                    remediationType: ["patch_cycle", "kb_install"]
                }
            },
            {
                name: "Linux Systems Team",
                priority: 2,
                conditions: {
                    platform: ["linux"],
                    remediationType: ["patch_cycle", "package_upgrade"]
                }
            },
            {
                name: "Application Development Team",
                priority: 3,
                conditions: {
                    component: ["java", "dotnet", "python", "nodejs", "spring_framework"]
                }
            },
            {
                name: "Web Infrastructure Team",
                priority: 4,
                conditions: {
                    component: ["apache", "nginx", "iis", "tomcat"]
                }
            },
            {
                name: "Desktop Engineering Team",
                priority: 5,
                conditions: {
                    component: ["firefox", "chrome", "edge", "safari"],
                    remediationType: ["software_upgrade"]
                }
            },
            {
                name: "Network Security Team",
                priority: 6,
                conditions: {
                    component: ["openssh", "ssl", "tls"],
                    remediationType: ["config_change", "operational_mitigation"]
                }
            },
            {
                name: "Security Operations Team",
                priority: 99,
                conditions: {},
                default: true
            }
        ];
        
        this.poamsCreated = 0;
        this.poamsSkipped = 0;
        this.skipReasons = {};
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // OVERRIDE: Enhanced Analysis Pipeline with SLA Gating
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    analyzeAndGroup(rawVulnerabilities) {
        console.log('\nüîç ‚ïê‚ïê‚ïê ENHANCED ANALYSIS ENGINE V3 STARTED ‚ïê‚ïê‚ïê');
        console.log(`üìä Total raw vulnerabilities: ${rawVulnerabilities.length}`);
        
        this.vulnerabilities = rawVulnerabilities;
        this.debugCount = 0;
        this.poamsCreated = 0;
        this.poamsSkipped = 0;
        this.skipReasons = {};
        
        // Step 1: Normalize findings
        console.log('\n‚öôÔ∏è  Step 1: Normalizing findings...');
        const normalized = this.normalizeFindings(rawVulnerabilities);
        console.log(`‚úÖ Normalized ${normalized.length} findings`);
        
        // Step 2: Calculate SLA breach status
        console.log('\n‚öôÔ∏è  Step 2: Calculating SLA breach status...');
        const withSLA = this.calculateSLAStatus(normalized);
        console.log(`‚úÖ SLA status calculated for ${withSLA.length} findings`);
        
        // Step 3: Classify remediation
        console.log('\n‚öôÔ∏è  Step 3: Classifying remediation strategies...');
        const classified = this.classifyRemediation(withSLA);
        console.log(`‚úÖ Classified ${classified.length} findings`);
        
        // Step 4: Group by remediation signature
        console.log('\n‚öôÔ∏è  Step 4: Grouping by remediation signatures...');
        const groups = this.groupByRemediationSignature(classified);
        console.log(`‚úÖ Created ${groups.size} unique remediation groups`);
        
        // Step 5: Apply SLA gating and build POAMs
        console.log('\n‚öôÔ∏è  Step 5: Applying SLA gating and building POAMs...');
        this.groupedPOAMs = this.buildPOAMsWithSLAGating(groups);
        console.log(`‚úÖ Created ${this.poamsCreated} POAMs (skipped ${this.poamsSkipped})`);
        
        // Step 6: Calculate confidence
        console.log('\n‚öôÔ∏è  Step 6: Calculating confidence scores...');
        this.calculatePOAMConfidence();
        console.log(`‚úÖ Confidence scoring complete`);
        
        // Log skip reasons
        if (this.poamsSkipped > 0) {
            console.log('\nüìã POAM Skip Reasons:');
            Object.entries(this.skipReasons).forEach(([reason, count]) => {
                console.log(`   ${reason}: ${count} groups`);
            });
        }
        
        console.log('\nüéØ ‚ïê‚ïê‚ïê ANALYSIS COMPLETE ‚ïê‚ïê‚ïê\n');
        
        return this.groupedPOAMs;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // SLA BREACH CALCULATION
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    calculateSLAStatus(findings) {
        const now = new Date();
        
        return findings.map(finding => {
            const firstDetected = this.parseDate(finding.firstDetected);
            const lastDetected = this.parseDate(finding.lastDetected);
            const status = finding.status || 'ACTIVE';
            const severity = this.normalizeSeverity(finding.severity || finding.risk);
            
            // Calculate age in days
            const ageDays = firstDetected ? this.daysBetween(firstDetected, now) : 0;
            
            // Get SLA days for this severity
            const slaDays = this.slaConfig[severity] || this.slaConfig.medium;
            
            // Determine if breached
            const breached = (status === 'ACTIVE' || status === 'NEW' || status === 'OPEN') && 
                           (ageDays > slaDays) && 
                           firstDetected !== null;
            
            // Calculate breach date
            const breachDate = firstDetected ? 
                this.addDays(firstDetected, slaDays) : null;
            
            return {
                ...finding,
                sla: {
                    severity,
                    slaDays,
                    ageDays,
                    breached,
                    breachDate: breachDate ? breachDate.toISOString().split('T')[0] : null,
                    firstDetected: firstDetected ? firstDetected.toISOString().split('T')[0] : null,
                    lastDetected: lastDetected ? lastDetected.toISOString().split('T')[0] : null,
                    status
                }
            };
        });
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ENHANCED POAM BUILDING WITH SLA GATING
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    buildPOAMsWithSLAGating(groups) {
        const poams = [];
        // Ensure sequential numbering starting from 001
        let poamIdCounter = 1;
        
        groups.forEach((group, signature) => {
            const rem = group.remediation;
            
            // Calculate breach status for this group
            const breachAnalysis = this.analyzeGroupBreach(group);
            
            // SLA Gating: Only create POAM if group is breached
            if (!breachAnalysis.groupBreached) {
                this.poamsSkipped++;
                this.skipReasons[breachAnalysis.skipReason] = 
                    (this.skipReasons[breachAnalysis.skipReason] || 0) + 1;
                
                // Debug first 5 skipped groups
                if (this.poamsSkipped <= 5) {
                    console.log(`\n‚è≠Ô∏è  Skipped Group: ${signature.substring(0, 80)}`);
                    console.log(`   Reason: ${breachAnalysis.skipReason}`);
                    console.log(`   Active Assets: ${breachAnalysis.activeAssets.size}`);
                    console.log(`   Breached Assets: ${breachAnalysis.breachedAssets.size}`);
                }
                return; // Skip this group
            }
            
            // Assign POC using rules engine
            const pocAssignment = this.assignPOC(rem, group);
            
            // Calculate due date from oldest breached asset
            const dueDate = breachAnalysis.oldestBreachDate;
            
            // Calculate days overdue
            const now = new Date();
            const breachDate = new Date(breachAnalysis.oldestBreachDate);
            const daysOverdue = this.daysBetween(breachDate, now);
            
            // Determine POAM status
            const poamStatus = this.determinePOAMStatus(rem, breachAnalysis, group);
            
            // Generate smart POAM description
            const description = this.generateSmartDescription(rem, group, breachAnalysis);
            
            // Select POAM title from scanner-provided titles (NOT generated)
            const poamTitle = this.selectPOAMTitle(rem, group, breachAnalysis);
            
            // Determine title rule used for debugging
            const titleRuleUsed = this.getTitleSelectionRule(rem, group);
            
            // Calculate all three asset counts
            const totalAffectedAssets = group.assets.size; // All assets with the finding
            const activeAssetCount = breachAnalysis.activeAssets.size; // Assets still detecting
            const breachedAssetCount = breachAnalysis.breachedAssets.size; // Assets out of SLA
            
            const poam = {
                // Database required fields
                id: `POAM-${String(poamIdCounter).padStart(4, '0')}`,
                
                // POAM source (MANDATORY)
                source: 'Vulnerability Scan Report',
                
                // Display fields
                title: poamTitle,
                description: description,
                
                // Remediation metadata
                remediationSignature: signature,
                remediationType: rem.remediationType,
                component: rem.component,
                platform: rem.platform,
                targetingStrategy: rem.targetingStrategy,
                fixedTarget: rem.fixedTarget,
                fixedTargetKey: rem.fixedTargetKey,
                actionText: rem.actionText,
                
                // Status and tracking
                status: poamStatus,
                risk: breachAnalysis.highestRisk,
                dueDate: dueDate,
                createdDate: new Date().toISOString().split('T')[0],
                
                // Priority fields for display and sorting
                daysOverdue: daysOverdue,
                breachedAssetCount: breachedAssetCount,
                
                // SLA and breach metadata
                slaBreached: true,
                slaDays: breachAnalysis.slaDays,
                oldestDetectionDate: breachAnalysis.oldestDetectionDate,
                breachDate: breachAnalysis.oldestBreachDate,
                
                // Asset counts (THREE COUNTS - CRITICAL)
                totalAffectedAssets: totalAffectedAssets,      // All assets with the finding
                activeAssets: activeAssetCount,                 // Assets still detecting
                breachedAssets: breachedAssetCount,            // Assets out of SLA
                assetCount: totalAffectedAssets,               // For UI list view display
                assetCountBreached: breachedAssetCount,        // For SLA compliance
                assetCountActive: activeAssetCount,            // For detail view
                assetCountWithinSLA: breachAnalysis.withinSlaAssets.size,
                findingCount: group.findings.length,
                
                // Aggregated data
                affectedAssets: Array.from(group.assets),      // All affected assets
                asset: Array.from(group.assets).join(', '),    // For database index
                breachedAssetsList: Array.from(breachAnalysis.breachedAssets),
                activeAssetsList: Array.from(breachAnalysis.activeAssets),
                withinSlaAssets: Array.from(breachAnalysis.withinSlaAssets),
                cves: Array.from(group.cves),
                qids: Array.from(group.qids),
                advisoryIds: Array.from(group.advisoryIds),
                
                // POC assignment
                poc: pocAssignment.pocTeam,
                pocTeam: pocAssignment.pocTeam,
                assignmentReason: pocAssignment.assignmentReason,
                recommendedOwner: pocAssignment.pocTeam,
                
                // Evidence
                evidenceSamples: group.evidenceSamples,
                
                // Confidence (will be calculated in step 6)
                confidenceScore: 0,
                needsReview: false,
                
                // Debug metadata
                debugInfo: {
                    whyPOAMCreated: `SLA breached: ${breachAnalysis.breachedAssets.size} assets exceeded ${breachAnalysis.slaDays}-day SLA for ${breachAnalysis.highestRisk} severity (oldest detection: ${breachAnalysis.oldestDetectionDate}, breach date: ${breachAnalysis.oldestBreachDate}, ${daysOverdue} days overdue)`,
                    whyPOAMSkipped: null,
                    titleRuleUsed: titleRuleUsed,
                    remediationType: rem.remediationType,
                    firstDetectedOldest: breachAnalysis.oldestDetectionDate,
                    daysOverdue: daysOverdue,
                    pocAssignmentRule: pocAssignment.ruleMatched,
                    pocAssignmentPrecedence: pocAssignment.precedence,
                    breachAnalysis: {
                        breachedCount: breachAnalysis.breachedAssets.size,
                        activeCount: breachAnalysis.activeAssets.size,
                        withinSlaCount: breachAnalysis.withinSlaAssets.size,
                        oldestAge: breachAnalysis.oldestAge,
                        slaDays: breachAnalysis.slaDays
                    }
                },
                
                // Raw findings for drill-down
                rawFindings: group.findings
            };
            
            poams.push(poam);
            this.poamsCreated++;
            poamIdCounter++;
            
            // Debug first 5 created POAMs
            if (this.poamsCreated <= 5) {
                console.log(`\n‚úÖ Created POAM #${this.poamsCreated}: ${poamTitle.substring(0, 80)}`);
                console.log(`   POC: ${pocAssignment.pocTeam} (${pocAssignment.assignmentReason})`);
                console.log(`   Breached Assets: ${breachAnalysis.breachedAssets.size}`);
                console.log(`   Due Date: ${dueDate}`);
                console.log(`   Confidence: Will be calculated`);
            }
        });
        
        return poams;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // BREACH ANALYSIS FOR GROUP
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    analyzeGroupBreach(group) {
        const breachedAssets = new Set();
        const activeAssets = new Set();
        const withinSlaAssets = new Set();
        
        let oldestDetectionDate = null;
        let oldestBreachDate = null;
        let oldestAge = 0;
        let highestRisk = 'low';
        let slaDays = 90;
        
        group.findings.forEach(finding => {
            const asset = finding.asset?.hostname || finding.asset?.assetId || 'unknown';
            const sla = finding.sla;
            
            if (!sla) return;
            
            // Track active assets
            if (sla.status === 'ACTIVE' || sla.status === 'NEW' || sla.status === 'OPEN') {
                activeAssets.add(asset);
                
                // Track breached vs within SLA
                if (sla.breached) {
                    breachedAssets.add(asset);
                    
                    // Track oldest detection
                    const detectionDate = new Date(sla.firstDetected);
                    if (!oldestDetectionDate || detectionDate < oldestDetectionDate) {
                        oldestDetectionDate = detectionDate;
                        oldestBreachDate = sla.breachDate;
                        oldestAge = sla.ageDays;
                        slaDays = sla.slaDays;
                    }
                } else {
                    withinSlaAssets.add(asset);
                }
            }
            
            // Track highest risk
            if (this.isHigherRisk(sla.severity, highestRisk)) {
                highestRisk = sla.severity;
            }
        });
        
        // Determine if group is breached
        const groupBreached = breachedAssets.size > 0;
        
        // Determine skip reason if not breached
        let skipReason = null;
        if (!groupBreached) {
            if (activeAssets.size === 0) {
                skipReason = 'No active findings (all fixed or closed)';
            } else if (withinSlaAssets.size > 0) {
                skipReason = 'All active findings within SLA';
            } else {
                skipReason = 'Missing detection dates';
            }
        }
        
        return {
            groupBreached,
            breachedAssets,
            activeAssets,
            withinSlaAssets,
            oldestDetectionDate: oldestDetectionDate ? oldestDetectionDate.toISOString().split('T')[0] : null,
            oldestBreachDate,
            oldestAge,
            highestRisk,
            slaDays,
            skipReason
        };
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ENHANCED CONFIDENCE SCORING (OVERRIDE)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    calculatePOAMConfidence() {
        this.groupedPOAMs.forEach(poam => {
            let score = 0;
            let maxScore = 0;
            const reviewReasons = [];
            
            // Advisory ID extracted (+40)
            maxScore += 40;
            if (poam.advisoryIds.length > 0) {
                score += 40;
            } else {
                reviewReasons.push('No advisory IDs extracted');
            }
            
            // Fixed target extracted (+30)
            maxScore += 30;
            if (poam.fixedTarget && poam.fixedTargetKey !== 'unknown') {
                score += 30;
            } else {
                reviewReasons.push('Fixed target not clearly identified');
            }
            
            // Remediation type confidently classified (+20)
            maxScore += 20;
            if (poam.remediationType !== 'unknown' && poam.remediationType !== 'no_action_unknown') {
                score += 20;
            } else {
                reviewReasons.push('Remediation type unclear');
            }
            
            // Component dictionary match (+15)
            maxScore += 15;
            if (this.componentDictionary[poam.component.toLowerCase()]) {
                score += 15;
            } else {
                reviewReasons.push('Component not in known dictionary');
            }
            
            // Current evidence extracted (+10)
            maxScore += 10;
            if (poam.evidenceSamples.length > 0) {
                score += 10;
            } else {
                reviewReasons.push('No evidence samples available');
            }
            
            // Calculate final score
            poam.confidenceScore = Math.round((score / maxScore) * 100);
            
            // Determine confidence level
            if (poam.confidenceScore >= 80) {
                poam.confidenceLevel = 'High';
            } else if (poam.confidenceScore >= 60) {
                poam.confidenceLevel = 'Medium';
            } else {
                poam.confidenceLevel = 'Low';
            }
            
            // Enhanced needsReview logic
            let needsReview = false;
            
            // Rule 1: Confidence score < 70
            if (poam.confidenceScore < 70) {
                needsReview = true;
                if (!reviewReasons.includes('Low confidence score')) {
                    reviewReasons.push('Low confidence score');
                }
            }
            
            // Rule 2: Windows patch cycle missing
            if (poam.remediationType === 'patch_cycle' && 
                poam.platform === 'windows' && 
                !poam.fixedTarget?.patchCycle) {
                needsReview = true;
                reviewReasons.push('Windows patch cycle date not detected');
            }
            
            // Rule 3: Conflicting fixed targets detected
            if (this.hasConflictingTargets(poam)) {
                needsReview = true;
                reviewReasons.push('Conflicting fixed targets detected in findings');
            }
            
            // Rule 4: Unassigned POC
            if (poam.pocTeam === 'Unassigned') {
                needsReview = true;
                reviewReasons.push('No POC team assigned');
            }
            
            poam.needsReview = needsReview;
            poam.reviewReasons = reviewReasons;
        });
    }
    
    hasConflictingTargets(poam) {
        // Check if raw findings have significantly different fixed targets
        if (!poam.rawFindings || poam.rawFindings.length < 2) return false;
        
        const targets = new Set();
        poam.rawFindings.forEach(f => {
            const target = f.remediation?.fixedTarget?.version || 
                          f.remediation?.fixedTarget?.patchCycle ||
                          f.remediation?.fixedTargetKey;
            if (target && target !== 'unknown' && target !== 'latest') {
                targets.add(target);
            }
        });
        
        // If more than 2 different specific targets, flag as conflicting
        return targets.size > 2;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // POC ASSIGNMENT RULES ENGINE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    assignPOC(remediation, group) {
        // Precedence: 1) Asset tags, 2) Platform, 3) Component class, 4) Fallback
        
        // 1) Check for explicit asset tags or boundary ownership (highest priority)
        const assetTagMatch = this.checkAssetTagRules(group.findings);
        if (assetTagMatch) {
            return {
                pocTeam: assetTagMatch.team,
                assignmentReason: `asset_tag=${assetTagMatch.tag}`,
                ruleMatched: 'Asset Tag Rule',
                precedence: 1
            };
        }
        
        // 2) Platform-based assignment
        const platformMatch = this.checkPlatformRules(remediation);
        if (platformMatch) {
            return {
                pocTeam: platformMatch.team,
                assignmentReason: `platform=${remediation.platform}`,
                ruleMatched: 'Platform Rule',
                precedence: 2
            };
        }
        
        // 3) Component class assignment
        const componentMatch = this.checkComponentRules(remediation);
        if (componentMatch) {
            return {
                pocTeam: componentMatch.team,
                assignmentReason: `component=${remediation.component}`,
                ruleMatched: 'Component Rule',
                precedence: 3
            };
        }
        
        // 4) Fallback - flag as unassigned priority
        return {
            pocTeam: 'Unassigned',
            assignmentReason: 'no_matching_rule',
            ruleMatched: 'Fallback',
            precedence: 99,
            flagAsPriority: true
        };
    }
    
    checkAssetTagRules(findings) {
        // Check for asset tags in findings
        for (const finding of findings.slice(0, 10)) {
            const tags = finding.assetTags || finding.asset?.assetTags || '';
            const tagsLower = tags.toLowerCase();
            
            if (tagsLower.includes('dmz') || tagsLower.includes('boundary')) {
                return { team: 'Network Security Team', tag: 'DMZ/Boundary' };
            }
            if (tagsLower.includes('pci') || tagsLower.includes('cardholder')) {
                return { team: 'PCI Compliance Team', tag: 'PCI' };
            }
            if (tagsLower.includes('critical') || tagsLower.includes('tier1')) {
                return { team: 'Critical Systems Team', tag: 'Critical/Tier1' };
            }
        }
        return null;
    }
    
    checkPlatformRules(remediation) {
        const platform = remediation.platform;
        const component = remediation.component;
        
        // Windows endpoint vs server distinction
        if (platform === 'windows') {
            // Check if it's endpoint software (browsers, etc.)
            if (['firefox', 'chrome', 'edge', 'safari'].includes(component)) {
                return { team: 'End User Computing Team' };
            }
            // Server components
            return { team: 'Windows Systems Team' };
        }
        
        if (platform === 'linux') {
            return { team: 'Linux Systems Team' };
        }
        
        if (platform === 'network') {
            return { team: 'Network Engineering Team' };
        }
        
        return null;
    }
    
    checkComponentRules(remediation) {
        const component = remediation.component;
        
        // Browsers
        if (['firefox', 'chrome', 'edge', 'safari'].includes(component)) {
            return { team: 'Desktop Engineering Team' };
        }
        
        // Application frameworks
        if (['java', 'dotnet', 'python', 'nodejs', 'spring_framework'].includes(component)) {
            return { team: 'Application Development Team' };
        }
        
        // Web servers
        if (['apache', 'nginx', 'iis', 'tomcat'].includes(component)) {
            return { team: 'Web Infrastructure Team' };
        }
        
        // Network/security components
        if (['openssh', 'ssl', 'tls'].includes(component)) {
            return { team: 'Network Security Team' };
        }
        
        return null;
    }
    
    evaluateRuleConditions(conditions, remediation, group) {
        if (!conditions || Object.keys(conditions).length === 0) return false;
        
        let matches = true;
        
        if (conditions.platform) {
            matches = matches && conditions.platform.includes(remediation.platform);
        }
        if (conditions.remediationType) {
            matches = matches && conditions.remediationType.includes(remediation.remediationType);
        }
        if (conditions.component) {
            matches = matches && conditions.component.includes(remediation.component);
        }
        
        return matches;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // SMART POAM DESCRIPTIONS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    generateSmartDescription(remediation, group, breachAnalysis) {
        const component = remediation.component.replace(/_/g, ' ');
        const componentTitle = component.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
        
        // Calculate days overdue
        const now = new Date();
        const breachDate = new Date(breachAnalysis.oldestBreachDate);
        const daysOverdue = this.daysBetween(breachDate, now);
        
        // Get latest detection date
        const latestDetected = this.getLatestDetectionDate(group.findings);
        
        // Build description with required sections
        let description = '';
        
        // 1) SUMMARY - One sentence matching the POAM title exactly
        description += '‚ïê‚ïê‚ïê SUMMARY ‚ïê‚ïê‚ïê\n';
        description += this.generateDescriptionSummary(remediation, componentTitle, group) + '\n\n';
        
        // 2) SCOPE - Breached and active asset counts
        description += '‚ïê‚ïê‚ïê SCOPE ‚ïê‚ïê‚ïê\n';
        description += `Breached Assets (Out of SLA): ${breachAnalysis.breachedAssets.size}\n`;
        description += `Total Active Affected Assets: ${breachAnalysis.activeAssets.size}\n`;
        description += `Assets Within SLA: ${breachAnalysis.withinSlaAssets.size}\n`;
        description += `Total Findings Consolidated: ${group.findings.length}\n\n`;
        
        // 3) SLA BREACH DETERMINATION - Explicit dates and overdue calculation
        description += '‚ïê‚ïê‚ïê SLA BREACH DETERMINATION ‚ïê‚ïê‚ïê\n';
        description += `Oldest First Detected: ${breachAnalysis.oldestDetectionDate}\n`;
        description += `Most Recent Last Detected: ${latestDetected}\n`;
        description += `Applicable SLA: ${breachAnalysis.slaDays} days (${breachAnalysis.highestRisk.toUpperCase()} severity)\n`;
        description += `SLA Breach Date: ${breachAnalysis.oldestBreachDate}\n`;
        description += `Days Overdue: ${daysOverdue} days\n\n`;
        
        // 4) REQUIRED REMEDIATION - Concrete action tied to remediationType
        description += '‚ïê‚ïê‚ïê REQUIRED REMEDIATION ‚ïê‚ïê‚ïê\n';
        description += this.generateRemediationAction(remediation, componentTitle, group) + '\n\n';
        
        // 5) VALIDATION METHOD - How remediation will be confirmed
        description += '‚ïê‚ïê‚ïê VALIDATION METHOD ‚ïê‚ïê‚ïê\n';
        description += this.generateValidationMethod(remediation, componentTitle) + '\n\n';
        
        // Additional context
        description += '‚ïê‚ïê‚ïê ADDITIONAL CONTEXT ‚ïê‚ïê‚ïê\n';
        const sampleCVEs = Array.from(group.cves).slice(0, 5).join(', ') || 'None';
        const sampleAdvisories = Array.from(group.advisoryIds).slice(0, 3).join(', ') || 'None';
        description += `Sample CVEs: ${sampleCVEs}\n`;
        if (sampleAdvisories !== 'None') {
            description += `Sample Advisories: ${sampleAdvisories}\n`;
        }
        if (group.evidenceSamples.length > 0) {
            description += `\nEvidence Sample:\n${group.evidenceSamples[0].substring(0, 200)}...\n`;
        }
        
        return description;
    }
    
    generateDescriptionSummary(remediation, componentTitle, group) {
        switch (remediation.remediationType) {
            case 'patch_cycle':
                if (remediation.platform === 'windows' && remediation.fixedTarget?.patchCycle) {
                    return `Windows ${remediation.fixedTarget.patchCycle} Security Updates are missing on the affected assets.`;
                }
                return `${componentTitle} security updates are missing on the affected assets.`;
                
            case 'kb_install':
                const kbIds = remediation.fixedTarget?.kbIds?.join(', ') || 'KB updates';
                return `Windows ${kbIds} are missing on the affected assets.`;
                
            case 'software_upgrade':
                if (remediation.targetingStrategy === 'latest_supported') {
                    return `${componentTitle} is below the approved latest release on the affected assets, resulting in multiple vulnerabilities.`;
                } else {
                    const targetVersion = remediation.fixedTarget?.version || remediation.fixedTargetKey;
                    return `${componentTitle} requires upgrade to version ${targetVersion} on the affected assets to address multiple vulnerabilities.`;
                }
                
            case 'vendor_fix':
                return `${componentTitle} requires vendor-provided security fix on the affected assets.`;
                
            case 'config_change':
                return `${componentTitle} configuration hardening is required on the affected assets.`;
                
            case 'operational_mitigation':
                return `${componentTitle} requires operational mitigation controls as no vendor patch is available.`;
                
            case 'package_upgrade':
                return `${componentTitle} package requires update on the affected assets.`;
                
            default:
                return `${componentTitle} requires remediation on the affected assets.`;
        }
    }
    
    generateRemediationAction(remediation, componentTitle, group) {
        switch (remediation.remediationType) {
            case 'patch_cycle':
                if (remediation.platform === 'windows' && remediation.fixedTarget?.patchCycle) {
                    return `Deploy the Windows ${remediation.fixedTarget.patchCycle} cumulative security updates to all affected assets using the standard Windows patch deployment process (WSUS/SCCM/Intune).`;
                }
                return `Deploy the latest security patches to all affected ${remediation.platform} systems using the standard patch management process.`;
                
            case 'kb_install':
                const kbIds = remediation.fixedTarget?.kbIds?.join(', ') || 'the required KB updates';
                return `Install ${kbIds} on all affected Windows systems using the standard Windows update deployment process.`;
                
            case 'software_upgrade':
                if (remediation.targetingStrategy === 'latest_supported') {
                    return `Upgrade ${componentTitle} to the approved latest release using the standard endpoint deployment process. Verify the approved version with the Change Advisory Board before deployment.`;
                } else {
                    const targetVersion = remediation.fixedTarget?.version || remediation.fixedTargetKey;
                    return `Upgrade ${componentTitle} to version ${targetVersion} or later using the standard application deployment process.`;
                }
                
            case 'vendor_fix':
                const advisory = Array.from(group.advisoryIds)[0] || 'vendor advisory';
                return `Apply the vendor-provided security fix per ${advisory} documentation. Follow vendor-specific installation procedures.`;
                
            case 'config_change':
                return `Apply the recommended configuration hardening per organizational security baseline. Document configuration changes in the change management system.`;
                
            case 'operational_mitigation':
                return `Implement compensating controls including: network segmentation to limit exposure, access restrictions via firewall rules or ACLs, enhanced monitoring and alerting for exploitation attempts. Document mitigation controls and monitor for vendor patch availability.`;
                
            case 'package_upgrade':
                const targetVersion = remediation.fixedTarget?.version || 'latest';
                return `Update ${componentTitle} package to version ${targetVersion} using the system package manager (yum/apt/dnf). Test in non-production environment before production deployment.`;
                
            default:
                return `Remediate ${componentTitle} vulnerabilities per vendor guidance and organizational security standards.`;
        }
    }
    
    generateValidationMethod(remediation, componentTitle) {
        switch (remediation.remediationType) {
            case 'patch_cycle':
            case 'kb_install':
            case 'software_upgrade':
            case 'package_upgrade':
                return `Validation will be performed by rescanning affected assets using the vulnerability scanner and confirming that ${componentTitle} findings are resolved. Verify that the installed version meets or exceeds the required version.`;
                
            case 'vendor_fix':
                return `Validation will be performed by rescanning affected assets and confirming that the vendor advisory findings are cleared. Verify fix installation through system evidence (installed packages, version checks).`;
                
            case 'config_change':
                return `Validation will be performed by rescanning affected assets and confirming that configuration findings are resolved. Verify configuration changes through system audits and compliance scans.`;
                
            case 'operational_mitigation':
                return `Validation will be performed by verifying that compensating controls are in place and effective. Document control implementation and maintain monitoring for vendor patch availability. Rescan to confirm no new exploitation attempts.`;
                
            default:
                return `Validation will be performed by rescanning affected assets and confirming that findings are resolved.`;
        }
    }
    
    getLatestDetectionDate(findings) {
        let latest = null;
        findings.forEach(f => {
            const lastDetected = f.sla?.lastDetected;
            if (lastDetected) {
                if (!latest || lastDetected > latest) {
                    latest = lastDetected;
                }
            }
        });
        return latest || 'Unknown';
    }
    
    getDescriptionTemplate(remediation) {
        const templateKey = remediation.remediationType === 'software_upgrade' ?
            (remediation.targetingStrategy === 'latest_supported' ? 
                'software_upgrade_latest' : 'software_upgrade_branched') :
            remediation.remediationType;
        
        const templates = {
            patch_cycle: "Apply {platform} security patches for {patchCycle}.\n\nAffected Systems: {assetCount} assets\nSeverity: {severity}\nFirst Detected: {firstDetected}\nSLA Breach Date: {breachDate}\n\nThis POAM consolidates {findingCount} findings that require the {patchCycle} patch cycle to be applied.\n\nSample CVEs: {sampleCVEs}\nSample Advisories: {sampleAdvisories}\n\nRemediation Action: Deploy {patchCycle} patches to all affected {platform} systems.",
            
            kb_install: "Install KB updates for {component}.\n\nAffected Systems: {assetCount} assets\nSeverity: {severity}\nKB Updates Required: {kbIds}\nFirst Detected: {firstDetected}\nSLA Breach Date: {breachDate}\n\nThis POAM consolidates {findingCount} findings requiring KB installation.\n\nSample CVEs: {sampleCVEs}\n\nRemediation Action: Install the following KB updates: {kbIds}",
            
            software_upgrade_latest: "Upgrade {component} to approved latest version on {platform} systems.\n\nAffected Systems: {assetCount} assets\nSeverity: {severity}\nCurrent Versions Detected: {currentVersions}\nTarget: Latest approved version\nFirst Detected: {firstDetected}\nSLA Breach Date: {breachDate}\n\nThis POAM consolidates {findingCount} findings across multiple CVEs that are all resolved by upgrading {component} to the latest approved version.\n\nSample CVEs: {sampleCVEs}\nSample Advisories: {sampleAdvisories}\n\nRemediation Action: Upgrade all instances of {component} to the latest approved version per organizational standards.",
            
            software_upgrade_branched: "Upgrade {component} to version {targetVersion} on {platform} systems.\n\nAffected Systems: {assetCount} assets\nSeverity: {severity}\nCurrent Versions Detected: {currentVersions}\nTarget Version: {targetVersion}\nFirst Detected: {firstDetected}\nSLA Breach Date: {breachDate}\n\nThis POAM consolidates {findingCount} findings for {component} version {majorVersion} track.\n\nSample CVEs: {sampleCVEs}\n\nRemediation Action: Upgrade {component} to version {targetVersion} or later within the {majorVersion} support track.",
            
            vendor_fix: "Apply vendor security fix per advisory {advisoryIds}.\n\nAffected Systems: {assetCount} assets\nSeverity: {severity}\nComponent: {component}\nAdvisory IDs: {advisoryIds}\nFirst Detected: {firstDetected}\nSLA Breach Date: {breachDate}\n\nThis POAM consolidates {findingCount} findings addressed by vendor advisory {advisoryIds}.\n\nSample CVEs: {sampleCVEs}\n\nRemediation Action: Apply vendor-provided fix per advisory documentation.",
            
            operational_mitigation: "Implement operational mitigation for {component} (no patch available).\n\nAffected Systems: {assetCount} assets\nSeverity: {severity}\nComponent: {component}\nFirst Detected: {firstDetected}\nSLA Breach Date: {breachDate}\n\nThis POAM consolidates {findingCount} findings with no vendor patch available.\n\nSample CVEs: {sampleCVEs}\n\nRemediation Action: Implement compensating controls such as network segmentation, access restrictions, or monitoring until vendor provides a patch.\n\nEvidence Samples:\n{evidenceSamples}",
            
            package_upgrade: "Update {component} package to version {targetVersion} on {platform} systems.\n\nAffected Systems: {assetCount} assets\nSeverity: {severity}\nCurrent Versions: {currentVersions}\nTarget Version: {targetVersion}\nFirst Detected: {firstDetected}\nSLA Breach Date: {breachDate}\n\nThis POAM consolidates {findingCount} findings for {component} package updates.\n\nSample CVEs: {sampleCVEs}\n\nRemediation Action: Update {component} package using system package manager (yum/apt/dnf)."
        };
        
        return templates[templateKey] || templates.software_upgrade_latest;
    }
    
    selectPOAMTitle(remediation, group, breachAnalysis) {
        // CRITICAL: Titles MUST come from scanner-provided vulnerability titles
        // Do NOT generate synthetic remediation prose
        
        const titles = group.findings.map(f => f.text?.title || '').filter(t => t);
        
        if (titles.length === 0) {
            return 'Unknown Vulnerability (No title provided by scanner)';
        }
        
        // Rule 1: If all findings share the same exact title, use it verbatim
        const uniqueTitles = [...new Set(titles)];
        if (uniqueTitles.length === 1) {
            return uniqueTitles[0];
        }
        
        // Rule 2: For latest_supported components, use dominant common prefix
        if (remediation.targetingStrategy === 'latest_supported') {
            const commonPrefix = this.findCommonPrefix(titles);
            if (commonPrefix && commonPrefix.length > 10) {
                // Use common prefix with "Multiple Vulnerabilities" suffix
                return `${commonPrefix.trim()} Multiple Vulnerabilities`;
            }
        }
        
        // Rule 3: Windows patch cycle - retain exact month-based titles
        if (remediation.remediationType === 'patch_cycle' && remediation.platform === 'windows') {
            // Look for month/year pattern in titles
            const patchTitle = titles.find(t => t.match(/\b(20\d{2})[-\s](0[1-9]|1[0-2])\b/) || 
                                                  t.match(/\b(January|February|March|April|May|June|July|August|September|October|November|December)\s+(20\d{2})\b/i));
            if (patchTitle) {
                return patchTitle;
            }
            // Fallback: use most common title
            return this.getMostCommonTitle(titles);
        }
        
        // Rule 4: Configuration and exposure findings - retain exact scanner titles
        if (remediation.remediationType === 'config_change' || 
            remediation.remediationType === 'operational_mitigation') {
            // Use the most common title (likely the canonical one)
            return this.getMostCommonTitle(titles);
        }
        
        // Rule 5: For other cases, use most common title
        return this.getMostCommonTitle(titles);
    }
    
    findCommonPrefix(titles) {
        if (titles.length === 0) return '';
        if (titles.length === 1) return titles[0];
        
        // Find longest common prefix
        let prefix = titles[0];
        for (let i = 1; i < titles.length; i++) {
            while (titles[i].indexOf(prefix) !== 0) {
                prefix = prefix.substring(0, prefix.length - 1);
                if (prefix === '') return '';
            }
        }
        
        // Trim to last complete word
        const lastSpace = prefix.lastIndexOf(' ');
        if (lastSpace > 0) {
            prefix = prefix.substring(0, lastSpace);
        }
        
        return prefix;
    }
    
    getMostCommonTitle(titles) {
        // Count occurrences of each title
        const counts = {};
        titles.forEach(title => {
            counts[title] = (counts[title] || 0) + 1;
        });
        
        // Return most common
        let maxCount = 0;
        let mostCommon = titles[0];
        Object.entries(counts).forEach(([title, count]) => {
            if (count > maxCount) {
                maxCount = count;
                mostCommon = title;
            }
        });
        
        return mostCommon;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // HELPER FUNCTIONS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    parseDate(dateString) {
        if (!dateString) return null;
        const date = new Date(dateString);
        return isNaN(date.getTime()) ? null : date;
    }
    
    daysBetween(date1, date2) {
        const msPerDay = 1000 * 60 * 60 * 24;
        return Math.floor((date2 - date1) / msPerDay);
    }
    
    addDays(date, days) {
        const result = new Date(date);
        result.setDate(result.getDate() + days);
        return result;
    }
    
    normalizeSeverity(severity) {
        if (!severity) return 'medium';
        const sev = severity.toLowerCase();
        if (sev.includes('critical') || sev === '5') return 'critical';
        if (sev.includes('high') || sev === '4') return 'high';
        if (sev.includes('medium') || sev === '3') return 'medium';
        if (sev.includes('low') || sev === '2' || sev === '1') return 'low';
        return 'medium';
    }
    
    isHigherRisk(risk1, risk2) {
        const levels = { critical: 4, high: 3, medium: 2, low: 1 };
        return (levels[risk1] || 0) > (levels[risk2] || 0);
    }
    
    extractUniqueVersions(findings) {
        const versions = new Set();
        findings.forEach(f => {
            if (f.evidence?.currentVersion) {
                versions.add(f.evidence.currentVersion);
            }
        });
        return Array.from(versions).slice(0, 5);
    }
    
    determinePOAMStatus(remediation, breachAnalysis, group) {
        // POAM status logic:
        // - Open: breachedAssets exist and activeAssets exist
        // - Closed: no activeAssets remain
        // - Mitigation: remediationType == operational_mitigation
        // - Risk Accepted: remediationType == risk_acceptance OR CSV status = "yes"
        
        // Check CSV status field (Column V) - if any finding has status "yes", set to risk-accepted
        if (group && group.findings) {
            const hasRiskAcceptedStatus = group.findings.some(finding => {
                const status = (finding.status || '').toLowerCase().trim();
                return status === 'yes' || status === 'risk accepted' || status === 'risk-accepted';
            });
            
            if (hasRiskAcceptedStatus) {
                console.log(`üîç Risk-accepted status detected in CSV for group with ${group.findings.length} findings`);
                return 'risk-accepted';
            }
        }
        
        if (remediation.remediationType === 'operational_mitigation') {
            return 'mitigation';
        }
        
        if (remediation.remediationType === 'risk_acceptance') {
            return 'risk_accepted';
        }
        
        if (breachAnalysis.activeAssets.size === 0) {
            return 'closed';
        }
        
        return 'open';
    }
    
    getTitleSelectionRule(remediation, group) {
        // Return which title SELECTION rule was used for debugging
        const titles = group.findings.map(f => f.text?.title || '').filter(t => t);
        const uniqueTitles = [...new Set(titles)];
        
        if (titles.length === 0) {
            return 'No scanner titles available';
        }
        
        if (uniqueTitles.length === 1) {
            return 'Single exact title (used verbatim)';
        }
        
        if (remediation.targetingStrategy === 'latest_supported') {
            return 'Latest-supported component (common prefix + Multiple Vulnerabilities)';
        }
        
        if (remediation.remediationType === 'patch_cycle' && remediation.platform === 'windows') {
            return 'Windows patch cycle (month-based title from scanner)';
        }
        
        if (remediation.remediationType === 'config_change' || 
            remediation.remediationType === 'operational_mitigation') {
            return 'Configuration/mitigation (most common scanner title)';
        }
        
        return 'Most common scanner title selected';
    }
}

// Export for use
if (typeof module !== 'undefined' && module.exports) {
    module.exports = VulnerabilityAnalysisEngineV3;
}
