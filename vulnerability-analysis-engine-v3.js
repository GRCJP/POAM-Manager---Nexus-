// Enhanced Vulnerability Analysis Engine V3
// Adds SLA Gating, POC Assignment Rules, and Smart POAM Descriptions
// Now with Baseline and Legacy Finding Support

console.log('âœ… vulnerability-analysis-engine-v3.js loaded successfully');

// Note: LEGACY_THRESHOLD_DAYS and RECENT_THRESHOLD_DAYS are defined in vulnerability-tracking.js

// POAM Template System for Automatic Field Population
const POAM_TEMPLATES = {
    PATCHING_UPDATES: {
        type: 'Patching/Updates',
        mitigation: 'Apply the latest vendor-provided patch or update to remediate the vulnerability.',
        milestones: [
            'Identify and obtain patch',
            'Test patch in staging environment',
            'Deploy patch to production',
            'Verify and close'
        ],
        impactedControls: ['SI-2'], // Flaw Remediation
        resources: 'Patch management team, system administrators, change management board',
        estimatedEffort: 'Medium - Depends on patch availability and testing requirements'
    },
    CONFIGURATION_CM: {
        type: 'Configuration/CM Controls',
        mitigation: 'Adjust system configuration to comply with required security baselines.',
        milestones: [
            'Assess current configuration',
            'Plan configuration changes',
            'Apply configuration updates',
            'Test and confirm'
        ],
        impactedControls: ['CM-6'], // Configuration Management
        resources: 'System administrators, security compliance team, configuration management',
        estimatedEffort: 'Low to Medium - Depends on complexity of configuration change'
    },
    SERVICE_REMEDIATION: {
        type: 'Service Remediation',
        mitigation: 'Update or reconfigure affected services to address security vulnerabilities.',
        milestones: [
            'Identify affected services and dependencies',
            'Update service configuration or version',
            'Test service functionality after changes',
            'Deploy to production and monitor for issues'
        ],
        impactedControls: ['SI-2', 'CM-6'],
        resources: 'Service owners, system administrators, DevOps team',
        estimatedEffort: 'Medium - Requires service downtime and testing'
    },
    ACCESS_CONTROL: {
        type: 'Access Control',
        mitigation: 'Modify user permissions and access controls to meet security requirements.',
        milestones: [
            'Review current permissions',
            'Define correct permissions',
            'Implement permission changes',
            'Validate and document'
        ],
        impactedControls: ['AC-3'], // Access Enforcement
        resources: 'System administrators, security team, user management',
        estimatedEffort: 'Low - Typically straightforward permission changes'
    },
    NETWORK_SECURITY: {
        type: 'Network Security',
        mitigation: 'Update network configurations and firewall rules to address vulnerabilities.',
        milestones: [
            'Analyze current network configuration',
            'Update firewall rules and network settings',
            'Test network connectivity and security',
            'Monitor for any issues or regressions'
        ],
        impactedControls: ['SC-7'], // Boundary Protection
        resources: 'Network engineers, security team, firewall administrators',
        estimatedEffort: 'Medium - Requires careful network changes and testing'
    },
    UNKNOWN: {
        type: 'Unknown/Other',
        mitigation: 'Further investigation required to determine appropriate remediation approach.',
        milestones: [
            'Analyze vulnerability details and impact',
            'Research appropriate remediation strategies',
            'Develop and implement remediation plan',
            'Test and validate remediation effectiveness'
        ],
        impactedControls: ['SI-2'],
        resources: 'Security team, system administrators, subject matter experts',
        estimatedEffort: 'Unknown - Requires further analysis'
    }
};

// Legacy Detection Functions
function isLegacyFinding(firstDetectedDate) {
    if (!firstDetectedDate) return false;
    
    const detectionDate = new Date(firstDetectedDate);
    const now = new Date();
    const daysSinceDetection = Math.floor((now - detectionDate) / (1000 * 60 * 60 * 24));
    
    return daysSinceDetection > LEGACY_THRESHOLD_DAYS;
}

function isRecentFinding(firstDetectedDate) {
    if (!firstDetectedDate) return false;
    
    const detectionDate = new Date(firstDetectedDate);
    const now = new Date();
    const daysSinceDetection = Math.floor((now - detectionDate) / (1000 * 60 * 60 * 24));
    
    return daysSinceDetection <= RECENT_THRESHOLD_DAYS;
}

function calculateDueDateForLegacy(riskLevel, firstDetectedDate) {
    const now = new Date();
    let slaDays = 120; // Default SLA for moderate
    
    // Updated SLA based on risk level
    switch (riskLevel?.toLowerCase()) {
        case 'critical':
            slaDays = 30;
            break;
        case 'high':
            slaDays = 60;
            break;
        case 'medium':
        case 'moderate':
            slaDays = 120;
            break;
        case 'low':
            slaDays = 240;
            break;
    }
    
    // For legacy findings, calculate from current date (not original detection)
    const dueDate = new Date(now.getTime() + (slaDays * 24 * 60 * 60 * 1000));
    return dueDate.toISOString().split('T')[0]; // Return YYYY-MM-DD format
}

function calculateDueDateForRecent(riskLevel, firstDetectedDate) {
    // For recent findings, use standard SLA from detection date
    let slaDays = 120; // Default SLA for moderate
    
    switch (riskLevel?.toLowerCase()) {
        case 'critical':
            slaDays = 30;
            break;
        case 'high':
            slaDays = 60;
            break;
        case 'medium':
        case 'moderate':
            slaDays = 120;
            break;
        case 'low':
            slaDays = 240;
            break;
    }
    
    const detectionDate = new Date(firstDetectedDate);
    const dueDate = new Date(detectionDate.getTime() + (slaDays * 24 * 60 * 60 * 1000));
    return dueDate.toISOString().split('T')[0]; // Return YYYY-MM-DD format
}

class VulnerabilityAnalysisEngineV3 extends VulnerabilityAnalysisEngineV2 {
    constructor() {
        super();
        
        // Baseline mode configuration
        this.isBaselineMode = false;
        this.baselinePOAMs = new Set(); // Store baseline POAM IDs for comparison
        
        // SLA Configuration (days by severity)
        this.slaConfig = {
            critical: 30,
            high: 60,
            medium: 120,
            moderate: 120,
            low: 240
        };
        
        // POC Assignment Rules (priority-based)
        this.pocRules = [
            {
                name: "Windows Systems Team",
                priority: 1,
                conditions: {
                    platform: ["windows"],
                    remediationType: ["patch_cycle", "kb_install"]
                }
            },
            {
                name: "Linux Systems Team",
                priority: 2,
                conditions: {
                    platform: ["linux"],
                    remediationType: ["patch_cycle", "package_upgrade"]
                }
            },
            {
                name: "Application Development Team",
                priority: 3,
                conditions: {
                    component: ["java", "dotnet", "python", "nodejs", "spring_framework"]
                }
            },
            {
                name: "Web Infrastructure Team",
                priority: 4,
                conditions: {
                    component: ["apache", "nginx", "iis", "tomcat"]
                }
            },
            {
                name: "Desktop Engineering Team",
                priority: 5,
                conditions: {
                    component: ["firefox", "chrome", "edge", "safari"],
                    remediationType: ["software_upgrade"]
                }
            },
            {
                name: "Network Security Team",
                priority: 6,
                conditions: {
                    component: ["openssh", "ssl", "tls"],
                    remediationType: ["config_change", "operational_mitigation"]
                }
            },
            {
                name: "Security Operations Team",
                priority: 99,
                conditions: {},
                default: true
            }
        ];
        
        this.poamsCreated = 0;
        this.poamsSkipped = 0;
        this.skipReasons = {};
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // BASELINE MANAGEMENT METHODS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    setBaselineMode(enabled) {
        this.isBaselineMode = enabled;
        console.log(`ğŸ“Š Baseline mode ${enabled ? 'ENABLED' : 'DISABLED'}`);
    }
    
    addToBaseline(poamId) {
        this.baselinePOAMs.add(poamId);
        console.log(`ğŸ“Š Added POAM ${poamId} to baseline`);
    }
    
    isInBaseline(poamId) {
        return this.baselinePOAMs.has(poamId);
    }
    
    generateBaselineKey(vulnerability) {
        // Create a unique key for baseline comparison based on vulnerability characteristics
        return `${vulnerability.cve || vulnerability.vulnerabilityName || vulnerability.title}_${vulnerability.asset || vulnerability.hostname}`;
    }
    
    isNearExpiry(dueDate) {
        if (!dueDate) return false;
        
        const now = new Date();
        const due = new Date(dueDate);
        const daysUntilDue = Math.floor((due - now) / (1000 * 60 * 60 * 24));
        
        return daysUntilDue <= 10 && daysUntilDue >= 0; // Within 10 days of due date
    }
    
    performBaselineComparison() {
        console.log('ğŸ“Š Performing baseline comparison...');
        
        this.groupedPOAMs.forEach(poam => {
            const baselineKey = this.generateBaselineKey(poam);
            
            // Check if this POAM matches a baseline POAM
            if (this.isInBaseline(baselineKey)) {
                // This is a known finding - check if it's near expiry
                if (this.isNearExpiry(poam.dueDate)) {
                    poam.status = 'overdue';
                    poam.baselineStatus = 'expired';
                    console.log(`âš ï¸ Baseline POAM ${poam.id} is near expiry and marked as overdue`);
                } else {
                    poam.baselineStatus = 'active';
                }
            } else {
                // This is a new finding not in baseline
                poam.baselineStatus = 'new';
            }
        });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // POAM TEMPLATE SYSTEM
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    determineFindingType(vulnerability, remediation) {
        const title = (vulnerability.title || vulnerability.vulnerabilityName || '').toLowerCase();
        const description = (vulnerability.description || '').toLowerCase();
        const remediationType = remediation?.remediationType || '';
        const actionText = (remediation?.actionText || '').toLowerCase();
        
        // Check for patching/update related findings
        if (this.isPatchingFinding(title, description, remediationType, actionText)) {
            return 'PATCHING_UPDATES';
        }
        
        // Check for configuration related findings
        if (this.isConfigurationFinding(title, description, remediationType, actionText)) {
            return 'CONFIGURATION_CM';
        }
        
        // Check for service related findings
        if (this.isServiceFinding(title, description, remediationType, actionText)) {
            return 'SERVICE_REMEDIATION';
        }
        
        // Check for access control findings
        if (this.isAccessControlFinding(title, description, remediationType, actionText)) {
            return 'ACCESS_CONTROL';
        }
        
        // Check for network security findings
        if (this.isNetworkFinding(title, description, remediationType, actionText)) {
            return 'NETWORK_SECURITY';
        }
        
        // Default to unknown
        return 'UNKNOWN';
    }
    
    isPatchingFinding(title, description, remediationType, actionText) {
        const patchKeywords = [
            'patch', 'update', 'upgrade', 'version', 'vulnerability', 'cve',
            'security update', 'hotfix', 'service pack', 'cumulative update'
        ];
        
        const text = [title, description, actionText].join(' ');
        
        return patchKeywords.some(keyword => text.includes(keyword)) ||
               remediationType.toLowerCase().includes('patch') ||
               remediationType.toLowerCase().includes('update');
    }
    
    isConfigurationFinding(title, description, remediationType, actionText) {
        const configKeywords = [
            'configuration', 'setting', 'baseline', 'policy', 'registry',
            'permission', 'parameter', 'option', 'control', 'hardening'
        ];
        
        const text = [title, description, actionText].join(' ');
        
        return configKeywords.some(keyword => text.includes(keyword)) ||
               remediationType.toLowerCase().includes('configuration') ||
               remediationType.toLowerCase().includes('setting');
    }
    
    isServiceFinding(title, description, remediationType, actionText) {
        const serviceKeywords = [
            'service', 'daemon', 'process', 'restart', 'stop', 'start',
            'disable', 'enable', 'configure service'
        ];
        
        const text = [title, description, actionText].join(' ');
        
        return serviceKeywords.some(keyword => text.includes(keyword)) ||
               remediationType.toLowerCase().includes('service');
    }
    
    isAccessControlFinding(title, description, remediationType, actionText) {
        const accessKeywords = [
            'access', 'permission', 'user', 'group', 'role', 'privilege',
            'authentication', 'authorization', 'login', 'account'
        ];
        
        const text = [title, description, actionText].join(' ');
        
        return accessKeywords.some(keyword => text.includes(keyword)) ||
               remediationType.toLowerCase().includes('access');
    }
    
    isNetworkFinding(title, description, remediationType, actionText) {
        const networkKeywords = [
            'firewall', 'port', 'network', 'protocol', 'tcp', 'udp',
            'ip', 'routing', 'switch', 'router', 'network device'
        ];
        
        const text = [title, description, actionText].join(' ');
        
        return networkKeywords.some(keyword => text.includes(keyword)) ||
               remediationType.toLowerCase().includes('network') ||
               remediationType.toLowerCase().includes('firewall');
    }
    
    generateEnhancedMitigationStrategy(vulnerability, remediation) {
        console.log('ğŸ”§ Generating enhanced mitigation strategy for:', vulnerability.title);
        console.log('ğŸ” Vulnerability data:', vulnerability);
        console.log('ğŸ” Available fields:', Object.keys(vulnerability));
        console.log('ğŸ” Solution field:', vulnerability.solution);
        console.log('ğŸ” Remediation data:', remediation);
        
        // Primary Source: Use Solution field if populated
        if (vulnerability.solution && vulnerability.solution.trim() !== '') {
            console.log('ğŸ”§ Using vendor solution as primary source');
            return this.generateVendorAuthoritativeMitigation(vulnerability);
        }
        
        console.log('ğŸ”§ Using fallback mitigation - no solution available');
        // Fallback: Use controlled templates based on finding type
        return this.generateFallbackMitigation(vulnerability, remediation);
    }
    
    generateVendorAuthoritativeMitigation(vulnerability) {
        const solution = vulnerability.solution.trim();
        console.log('ğŸ“‹ Using vendor solution as primary source:', solution);
        
        // Extract key information from solution
        const extracted = this.extractSolutionDetails(solution, vulnerability);
        
        // Generate audit-ready mitigation text
        let mitigation = '';
        
        // Action statement
        if (extracted.action) {
            mitigation += extracted.action;
        } else {
            mitigation += `Apply the vendor-provided remediation`;
        }
        
        // Authority reference
        if (extracted.authority) {
            mitigation += ` in accordance with ${extracted.authority}`;
        }
        
        // Implementation guidance
        mitigation += `. Apply the update using enterprise patch management tools`;
        
        // Validation steps
        mitigation += `. Validate remediation by rescanning affected systems and confirming the installed version meets the required level and the vulnerability is no longer detected`;
        
        console.log('âœ… Generated vendor-authoritative mitigation:', mitigation);
        return mitigation;
    }
    
    extractSolutionDetails(solution, vulnerability) {
        const extracted = {
            action: '',
            authority: '',
            version: '',
            vendor: ''
        };
        
        // Extract product names and versions
        const versionPatterns = [
            /upgrade\s+(\w+)\s+to\s+version\s+(\d+(?:\.\d+)*(?:\.\d+)?)/i,
            /update\s+(\w+)\s+to\s+(\d+(?:\.\d+)*(?:\.\d+)?)/i,
            /(\w+)\s+version\s+(\d+(?:\.\d+)*(?:\.\d+)?)/i,
            /apply\s+patch\s+(.+)/i,
            /install\s+(.+?)\s+patch/i
        ];
        
        for (const pattern of versionPatterns) {
            const match = solution.match(pattern);
            if (match) {
                extracted.action = `Upgrade ${match[1]} to version ${match[2]}`;
                extracted.version = match[2];
                break;
            }
        }
        
        // Extract vendor advisories and CVEs
        const advisoryPatterns = [
            /(?:advisory|bulletin|kb)\s+([A-Z]{2,}-\d{4,}-\d+)/i,
            /([A-Z]{2,}-\d{4,}-\d+)/i,
            /CVE-\d{4}-\d{4,}/gi,
            /KB\d{6,}/gi
        ];
        
        const advisories = [];
        for (const pattern of advisoryPatterns) {
            const matches = solution.match(pattern);
            if (matches) {
                advisories.push(...matches);
            }
        }
        
        if (advisories.length > 0) {
            extracted.authority = advisories.join(', ');
        }
        
        // Extract vendor information
        const vendorPatterns = [
            /mozilla|firefox/i,
            /microsoft|windows|office/i,
            /oracle|java/i,
            /apache|tomcat|iis/i,
            /cisco|ios/i,
            /linux|ubuntu|redhat|centos/i,
            /google|chrome/i
        ];
        
        for (const pattern of vendorPatterns) {
            if (solution.match(pattern)) {
                extracted.vendor = pattern.source.replace(/[|\\]/g, '');
                break;
            }
        }
        
        // If no specific action found, create a generic one
        if (!extracted.action) {
            if (extracted.vendor) {
                extracted.action = `Apply the latest vendor-provided update for ${extracted.vendor}`;
            } else {
                extracted.action = `Apply the latest vendor-provided patch or update`;
            }
        }
        
        return extracted;
    }
    
    generateFallbackMitigation(vulnerability, remediation) {
        console.log('âš ï¸ Using fallback mitigation - no solution field available');
        
        const findingType = this.determineFindingType(vulnerability, remediation);
        const template = POAM_TEMPLATES[findingType];
        
        if (!template) {
            return this.generateGenericMitigation(vulnerability);
        }
        
        // Enhance template with specific details
        let enhancedMitigation = template.mitigation;
        
        // Add specific validation steps
        enhancedMitigation += `. Validate remediation by: 1) confirming the configuration changes are applied, 2) rescanning to verify vulnerability resolution, 3) documenting evidence of compliance`;
        
        // Add reference to absence of vendor fix if applicable
        if (remediation.remediationType && remediation.remediationType.includes('operational_mitigation')) {
            enhancedMitigation = `No vendor patch is currently available for this vulnerability. Implement compensating controls: ${enhancedMitigation}`;
        }
        
        return enhancedMitigation;
    }
    
    generateGenericMitigation(vulnerability) {
        console.log('âš ï¸ Using generic mitigation - no template found');
        
        return `Further investigation required to determine appropriate remediation approach for ${vulnerability.title || 'this vulnerability'}. Analyze the vulnerability details, research vendor guidance, and implement appropriate security controls. Validate remediation through testing and verification procedures.`;
    }
    
    isPatchableVulnerability(vulnerability, remediation, group) {
        // Check remediation type - patches are patchable
        if (remediation.remediationType === 'patch' || 
            remediation.remediationType === 'package_upgrade' ||
            remediation.remediationType === 'version_upgrade') {
            return true;
        }
        
        // Check if solution contains patch-related keywords
        const solutions = group.findings
            .map(f => (f.solution || '').toLowerCase())
            .filter(s => s && s.trim() !== '');
        
        const patchKeywords = ['patch', 'update', 'upgrade', 'hotfix', 'service pack', 'install', 'apply'];
        const hasPatchSolution = solutions.some(solution => 
            patchKeywords.some(keyword => solution.includes(keyword))
        );
        
        if (hasPatchSolution) {
            return true;
        }
        
        // If remediation type is operational mitigation or config change, it's not patchable
        if (remediation.remediationType === 'operational_mitigation' || 
            remediation.remediationType === 'config_change') {
            return false;
        }
        
        // Default: assume patchable if we have a solution
        return solutions.length > 0;
    }

    applyPOAMTemplate(poam, findingType, vulnerability, remediation, group) {
        console.log(`ğŸ”§ Applying POAM template for ${findingType} to POAM ${poam.id}`);
        
        // Generate enhanced mitigation strategy
        poam.mitigation = this.generateEnhancedMitigationStrategy(vulnerability, remediation);
        
        // Store affected assets separately for dedicated tab/section
        poam.affectedAssets = this.getAffectedAssetsForDisplay(group);
        console.log(`ğŸ¢ Stored ${poam.affectedAssets.length} affected assets for POAM ${poam.id}`);
        
        const template = POAM_TEMPLATES[findingType];
        
        // Determine if vulnerability is patchable for control family mapping
        const isPatchable = this.isPatchableVulnerability(vulnerability, remediation, group);
        console.log(`ğŸ” Vulnerability patchable: ${isPatchable} (remediation type: ${remediation.remediationType})`);
        
        if (!template) {
            console.warn(`âš ï¸ No template found for finding type: ${findingType}`);
            // Still apply basic fields
            poam.findingType = 'Unknown/Other';
            poam.milestones = [
                'Analyze vulnerability details and impact',
                'Research appropriate remediation strategies',
                'Develop and implement remediation plan',
                'Test and validate remediation effectiveness'
            ];
            // Apply control family based on patchability
            poam.impactedControls = isPatchable ? ['SI-2'] : ['CM-6'];
            poam.controlFamily = isPatchable ? 'SI' : 'CM';
            poam.resources = 'Security team, system administrators, subject matter experts';
            poam.estimatedEffort = 'Unknown - Requires further analysis';
        } else {
            // Apply template fields (except mitigation which is already enhanced)
            poam.findingType = template.type;
            poam.milestones = template.milestones;
            
            // Override impactedControls based on patchability
            if (isPatchable) {
                poam.impactedControls = ['SI-2']; // Flaw Remediation
                poam.controlFamily = 'SI';
                console.log(`âœ… Patchable vulnerability - assigned SI-2 control`);
            } else {
                poam.impactedControls = ['CM-6']; // Configuration Management
                poam.controlFamily = 'CM';
                console.log(`âœ… Non-patchable vulnerability - assigned CM-6 control`);
            }
            
            poam.resources = template.resources;
            poam.estimatedEffort = template.estimatedEffort;
        }
        
        // Set standard fields
        poam.detectionSource = 'Vulnerability Scanning Tool';
        poam.status = poam.status || 'Open'; // Default to Open if not already set
        
        console.log(`ğŸ“‹ Applied enhanced template for ${poam.findingType || 'Unknown'} to POAM ${poam.id}`);
        console.log(`ğŸ”§ Generated mitigation: ${poam.mitigation.substring(0, 100)}...`);
        return poam;
    }
    
    // ... (rest of the code remains the same)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    async analyzeAndGroup(rawVulnerabilities, scanId = null) {
        console.log('\nğŸ” â•â•â• ENHANCED ANALYSIS ENGINE V3 STARTED â•â•â•');
        console.log(`ğŸ“Š Total raw vulnerabilities: ${rawVulnerabilities.length}`);
        if (scanId) {
            console.log(`ğŸ“¸ Scan ID: ${scanId}`);
        }
        
        this.vulnerabilities = rawVulnerabilities;
        this.scanId = scanId; // Store for later use
        this.debugCount = 0;
        this.poamsCreated = 0;
        this.poamsSkipped = 0;
        this.skipReasons = {};
        
        // Step 1: Normalize findings
        console.log('\nâš™ï¸  Step 1: Normalizing findings...');
        const normalized = this.normalizeFindings(rawVulnerabilities);
        console.log(`âœ… Normalized ${normalized.length} findings`);
        
        // Step 2: Calculate SLA breach status
        console.log('\nâš™ï¸  Step 2: Calculating SLA breach status...');
        const withSLA = this.calculateSLAStatus(normalized);
        console.log(`âœ… SLA status calculated for ${withSLA.length} findings`);
        
        // Step 3: Classify remediation
        console.log('\nâš™ï¸  Step 3: Classifying remediation strategies...');
        const classified = this.classifyRemediation(withSLA);
        console.log(`âœ… Classified ${classified.length} findings`);
        
        // Step 4: Group by remediation signature
        console.log('\nâš™ï¸  Step 4: Grouping by remediation signatures...');
        const groups = this.groupByRemediationSignature(classified);
        console.log(`âœ… Created ${groups.size} unique remediation groups`);
        
        // Step 5: Apply SLA gating and build POAMs
        console.log('\nâš™ï¸  Step 5: Applying SLA gating and building POAMs...');
        let poamsResult;
        try {
            poamsResult = await this.buildPOAMsWithSLAGating(groups);
            console.log('ğŸ” poamsResult from buildPOAMsWithSLAGating:', poamsResult);
            console.log('ğŸ” poamsResult type:', typeof poamsResult);
            console.log('ğŸ” poamsResult length:', poamsResult?.length || 'undefined');
        } catch (error) {
            console.error('âŒ Error in buildPOAMsWithSLAGating await:', error);
            console.error('âŒ Error stack:', error.stack);
            poamsResult = [];
        }
        
        this.groupedPOAMs = poamsResult;
        console.log(`âœ… Created ${this.poamsCreated} POAMs (skipped ${this.poamsSkipped})`);
        
        // Step 6: Calculate confidence
        console.log('\nâš™ï¸  Step 6: Calculating confidence scores...');
        console.log('ğŸ” groupedPOAMs:', this.groupedPOAMs);
        console.log('ğŸ” groupedPOAMs length:', this.groupedPOAMs?.length || 'undefined');
        
        if (!this.groupedPOAMs || !Array.isArray(this.groupedPOAMs)) {
            console.error('âŒ groupedPOAMs is not defined or not an array, skipping confidence calculation');
            return this.groupedPOAMs || [];
        }
        
        this.calculatePOAMConfidence();
        console.log(`âœ… Confidence scoring complete`);
        
        // Step 7: Handle baseline comparison if not in baseline mode
        if (!this.isBaselineMode) {
            console.log('\nâš™ï¸  Step 7: Performing baseline comparison...');
            this.performBaselineComparison();
            console.log(`âœ… Baseline comparison complete`);
        }
        
        // Log skip reasons
        if (this.poamsSkipped > 0) {
            console.log('\nğŸ“‹ POAM Skip Reasons:');
            Object.entries(this.skipReasons).forEach(([reason, count]) => {
                console.log(`   ${reason}: ${count} groups`);
            });
        }
        
        console.log('\nğŸ¯ â•â•â• ANALYSIS COMPLETE â•â•â•\n');
        
        return this.groupedPOAMs;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SLA BREACH CALCULATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    calculateSLAStatus(findings) {
        const now = new Date();
        
        return findings.map(finding => {
            const firstDetected = this.parseDate(finding.firstDetected);
            const lastDetected = this.parseDate(finding.lastDetected);
            const status = finding.status || 'ACTIVE';
            const severity = this.normalizeSeverity(finding.severity || finding.risk);
            
            // Calculate age in days
            const ageDays = firstDetected ? this.daysBetween(firstDetected, now) : 0;
            
            // Get SLA days for this severity
            const slaDays = this.slaConfig[severity] || this.slaConfig.medium;
            
            // Determine if breached
            const breached = (status === 'ACTIVE' || status === 'NEW' || status === 'OPEN') && 
                           (ageDays > slaDays) && 
                           firstDetected !== null;
            
            // Calculate breach date
            const breachDate = firstDetected ? 
                this.addDays(firstDetected, slaDays) : null;
            
            return {
                ...finding,
                sla: {
                    severity,
                    slaDays,
                    ageDays,
                    breached,
                    breachDate: breachDate ? breachDate.toISOString().split('T')[0] : null,
                    firstDetected: firstDetected ? firstDetected.toISOString().split('T')[0] : null,
                    lastDetected: lastDetected ? lastDetected.toISOString().split('T')[0] : null,
                    status
                }
            };
        });
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ENHANCED POAM BUILDING WITH SLA GATING
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    async buildPOAMsWithSLAGating(groups) {
        const poams = [];
        let poamIdCounter = 1;
        this.poamsCreated = 0;
        this.poamsSkipped = 0;
        this.skipReasons = {};

        console.log(`ğŸ”§ Building POAMs from ${groups.size} remediation groups...`);
        
        try {
            for (const [signature, group] of groups) {
                const rem = group.remediation;
                
                // Analyze group breach status
                const breachAnalysis = this.analyzeGroupBreach(group);
                
                // SLA Gating: Only create POAM if group is breached
                if (!breachAnalysis.groupBreached) {
                this.poamsSkipped++;
                this.skipReasons[breachAnalysis.skipReason] = 
                    (this.skipReasons[breachAnalysis.skipReason] || 0) + 1;
                
                // Debug first 5 skipped groups
                if (this.poamsSkipped <= 5) {
                    console.log(`\nâ­ï¸  Skipped Group: ${signature.substring(0, 80)}`);
                    console.log(`   Reason: ${breachAnalysis.skipReason}`);
                    console.log(`   Active Assets: ${breachAnalysis.activeAssets.size}`);
                    console.log(`   Breached Assets: ${breachAnalysis.breachedAssets.size}`);
                }
                continue; // Skip this group
            }
            
            // Assign POC using rules engine
            const pocAssignment = this.assignPOC(rem, group);
            
            // Legacy and Baseline Detection
            const firstDetectedDate = breachAnalysis.oldestDetectionDate;
            const isLegacy = isLegacyFinding(firstDetectedDate);
            const isRecent = isRecentFinding(firstDetectedDate);
            
            // Calculate due date based on legacy/recent status and baseline mode
            let calculatedDueDate;
            if (this.isBaselineMode) {
                // BASELINE IMPORT: All POAMs get fresh due dates from current date
                calculatedDueDate = calculateDueDateForLegacy(breachAnalysis.highestRisk, firstDetectedDate);
                console.log(`ğŸ“Š Baseline mode: POAM will get fresh due date from current date`);
            } else {
                // FUTURE SCANS: Use normal logic (legacy gets fresh date, recent uses detection date)
                if (isLegacy) {
                    calculatedDueDate = calculateDueDateForLegacy(breachAnalysis.highestRisk, firstDetectedDate);
                } else if (isRecent) {
                    calculatedDueDate = calculateDueDateForRecent(breachAnalysis.highestRisk, firstDetectedDate);
                } else {
                    // Standard due date calculation for normal findings
                    calculatedDueDate = breachAnalysis.oldestBreachDate;
                }
            }
            
            // Calculate days overdue
            const now = new Date();
            const breachDate = new Date(calculatedDueDate);
            const daysOverdue = this.daysBetween(breachDate, now);
            
            // Determine POAM status
            const poamStatus = this.determinePOAMStatus(rem, breachAnalysis, group);
            
            // Compute finding description from scan data (CVE-Description/description)
            const findingDescriptionDisplay = this.computeFindingDescriptionDisplay(
                group.findings,
                rem.actionText || group.findings[0]?.title
            );
            
            // Select POAM title from scanner-provided titles (NOT generated)
            const poamTitle = this.selectPOAMTitle(rem, group, breachAnalysis);
            
            // Determine title rule used for debugging
            const titleRuleUsed = this.getTitleSelectionRule(rem, group);
            
            // Calculate all three asset counts
            const totalAffectedAssets = group.assets.size; // All assets with the finding
            const activeAssetCount = breachAnalysis.activeAssets.size; // Assets still detecting
            const breachedAssetCount = breachAnalysis.breachedAssets.size; // Assets out of SLA
            
            const poam = {
                // Database required fields
                id: `POAM-${String(poamIdCounter).padStart(4, '0')}`,
                
                // POAM source (MANDATORY)
                source: 'Vulnerability Scan Report',
                
                // Display fields
                title: poamTitle,
                description: findingDescriptionDisplay,
                findingDescription: findingDescriptionDisplay,
                
                // Remediation metadata
                remediationSignature: signature,
                remediationType: rem.remediationType,
                component: rem.component,
                platform: rem.platform,
                targetingStrategy: rem.targetingStrategy,
                fixedTarget: rem.fixedTarget,
                fixedTargetKey: rem.fixedTargetKey,
                actionText: rem.actionText,
                
                // Status and tracking
                status: poamStatus,
                risk: breachAnalysis.highestRisk,
                dueDate: calculatedDueDate,
                createdDate: new Date().toISOString().split('T')[0],
                
                // Legacy and Baseline Information
                isLegacy: isLegacy,
                isRecent: isRecent,
                firstDetectedDate: firstDetectedDate,
                baselineType: isLegacy ? 'Legacy' : (isRecent ? 'Recent' : 'Standard'),
                
                // Priority fields for display and sorting
                daysOverdue: daysOverdue,
                breachedAssetCount: breachedAssetCount,
                
                // SLA and breach metadata
                slaBreached: true,
                slaDays: breachAnalysis.slaDays,
                oldestDetectionDate: breachAnalysis.oldestDetectionDate,
                breachDate: breachAnalysis.oldestBreachDate,
                
                // Asset counts (THREE COUNTS - CRITICAL)
                totalAffectedAssets: totalAffectedAssets,      // All assets with the finding
                activeAssets: activeAssetCount,                 // Assets still detecting
                breachedAssets: breachedAssetCount,            // Assets out of SLA
                assetCount: totalAffectedAssets,               // For UI list view display
                assetCountBreached: breachedAssetCount,        // For SLA compliance
                assetCountActive: activeAssetCount,            // For detail view
                assetCountWithinSLA: breachAnalysis.withinSlaAssets.size,
                findingCount: group.findings.length,
                
                // Aggregated data
                affectedAssets: Array.from(group.assets),      // All affected assets
                asset: Array.from(group.assets).join(', '),    // For database index
                breachedAssetsList: Array.from(breachAnalysis.breachedAssets),
                activeAssetsList: Array.from(breachAnalysis.activeAssets),
                withinSlaAssets: Array.from(breachAnalysis.withinSlaAssets),
                cves: Array.from(group.cves),
                qids: Array.from(group.qids),
                advisoryIds: Array.from(group.advisoryIds),
                
                // POC assignment
                poc: pocAssignment.pocTeam,
                pocTeam: pocAssignment.pocTeam,
                assignmentReason: pocAssignment.assignmentReason,
                recommendedOwner: pocAssignment.pocTeam,
                
                // Resources Required (standardized, audit-ready default)
                resourcesRequired: 'Personnel Time',
                
                // Evidence
                evidenceSamples: group.evidenceSamples,
                
                // Confidence (will be calculated in step 6)
                confidenceScore: 0,
                needsReview: false,
                
                // Debug metadata
                debugInfo: {
                    whyPOAMCreated: `SLA breached: ${breachAnalysis.breachedAssets.size} assets exceeded ${breachAnalysis.slaDays}-day SLA for ${breachAnalysis.highestRisk} severity (oldest detection: ${breachAnalysis.oldestDetectionDate}, breach date: ${breachAnalysis.oldestBreachDate}, ${daysOverdue} days overdue)`,
                    whyPOAMSkipped: null,
                    titleRuleUsed: titleRuleUsed,
                    remediationType: rem.remediationType,
                    firstDetectedOldest: breachAnalysis.oldestDetectionDate,
                    daysOverdue: daysOverdue,
                    pocAssignmentRule: pocAssignment.ruleMatched,
                    pocAssignmentPrecedence: pocAssignment.precedence,
                    breachAnalysis: {
                        breachedCount: breachAnalysis.breachedAssets.size,
                        activeCount: breachAnalysis.activeAssets.size,
                        withinSlaCount: breachAnalysis.withinSlaAssets.size,
                        oldestAge: breachAnalysis.oldestAge,
                        slaDays: breachAnalysis.slaDays
                    }
                },
                
                // Raw findings for drill-down
                rawFindings: group.findings,
                
                // Risk acceptance tracking
                ignoredFindingsCount: group.findings.filter(f => f.ignored === true).length,
                hasIgnoredFindings: group.findings.some(f => f.ignored === true)
            };
            
            // Apply POAM template for automatic field population
            const findingType = this.determineFindingType(group.findings[0], rem);
            const enhancedPOAM = this.applyPOAMTemplate(poam, findingType, group.findings[0], rem, group);
            
            // Create PoamScanSummary if we have a scanId
            if (this.scanId) {
                try {
                    console.log(`ğŸ” About to create scan summary for POAM ${poam.id}`);
                    const scanSummary = this.createScanSummary(poam.id, group, rem);
                    console.log(`ğŸ” Created scan summary object for POAM ${poam.id}`);
                    await this.saveScanSummary(scanSummary);
                    console.log(`ğŸ” Saved scan summary for POAM ${poam.id}`);
                    
                    // Link POAM to latest scan
                    enhancedPOAM.latestScanId = this.scanId;
                    enhancedPOAM.latestSummaryId = scanSummary.id;
                } catch (error) {
                    console.error(`âŒ Failed to create scan summary for POAM ${poam.id}:`, error);
                    console.error(`âŒ Error stack:`, error.stack);
                    // Continue without scan summary - POAM will still be created
                }
            }
            
            poams.push(enhancedPOAM);
            this.poamsCreated++;
            poamIdCounter++;
            
            // Debug first 5 created POAMs
            if (this.poamsCreated <= 5) {
                console.log(`\nâœ… Created POAM #${this.poamsCreated}: ${poamTitle.substring(0, 80)}`);
                console.log(`   POC: ${pocAssignment.pocTeam} (${pocAssignment.assignmentReason})`);
                console.log(`   Breached Assets: ${breachAnalysis.breachedAssets.size}`);
                console.log(`   Due Date: ${calculatedDueDate}`);
                console.log(`   Confidence: Will be calculated`);
            }
        }
        
        console.log(`ğŸ” About to return from buildPOAMsWithSLAGating`);
        console.log(`ğŸ” buildPOAMsWithSLAGating returning ${poams.length} POAMs`);
        console.log('ğŸ” POAMs array:', poams);
        console.log('ğŸ” POAMs array type:', typeof poams);
        console.log('ğŸ” POAMs array isArray:', Array.isArray(poams));
        return poams;
        } catch (error) {
            console.error('âŒ Exception in buildPOAMsWithSLAGating:', error);
            console.error('âŒ Error stack:', error.stack);
            return [];
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // BREACH ANALYSIS FOR GROUP
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    analyzeGroupBreach(group) {
        const breachedAssets = new Set();
        const activeAssets = new Set();
        const withinSlaAssets = new Set();
        
        let oldestDetectionDate = null;
        let oldestBreachDate = null;
        let oldestAge = 0;
        let highestRisk = 'low';
        let slaDays = 90;
        
        group.findings.forEach(finding => {
            const asset = finding.asset?.hostname || finding.asset?.assetId || 'unknown';
            const sla = finding.sla;
            
            if (!sla) return;
            
            // Track active assets
            if (sla.status === 'ACTIVE' || sla.status === 'NEW' || sla.status === 'OPEN') {
                activeAssets.add(asset);
                
                // Track breached vs within SLA
                if (sla.breached) {
                    breachedAssets.add(asset);
                    
                    // Track oldest detection
                    const detectionDate = new Date(sla.firstDetected);
                    if (!oldestDetectionDate || detectionDate < oldestDetectionDate) {
                        oldestDetectionDate = detectionDate;
                        oldestBreachDate = sla.breachDate;
                        oldestAge = sla.ageDays;
                        slaDays = sla.slaDays;
                    }
                } else {
                    withinSlaAssets.add(asset);
                }
            }
            
            // Track highest risk
            if (this.isHigherRisk(sla.severity, highestRisk)) {
                highestRisk = sla.severity;
            }
        });
        
        // Determine if group is breached
        const groupBreached = breachedAssets.size > 0;
        
        // Determine skip reason if not breached
        let skipReason = null;
        if (!groupBreached) {
            if (activeAssets.size === 0) {
                skipReason = 'No active findings (all fixed or closed)';
            } else if (withinSlaAssets.size > 0) {
                skipReason = 'All active findings within SLA';
            } else {
                skipReason = 'Missing detection dates';
            }
        }
        
        return {
            groupBreached,
            breachedAssets,
            activeAssets,
            withinSlaAssets,
            oldestDetectionDate: oldestDetectionDate ? oldestDetectionDate.toISOString().split('T')[0] : null,
            oldestBreachDate,
            oldestAge,
            highestRisk,
            slaDays,
            skipReason
        };
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ENHANCED CONFIDENCE SCORING (OVERRIDE)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    calculatePOAMConfidence() {
        if (!this.groupedPOAMs || !Array.isArray(this.groupedPOAMs)) {
            console.error('âŒ calculatePOAMConfidence: groupedPOAMs is not defined or not an array');
            return;
        }
        
        console.log(`ğŸ” Calculating confidence for ${this.groupedPOAMs.length} POAMs`);
        this.groupedPOAMs.forEach(poam => {
            let score = 0;
            let maxScore = 0;
            const reviewReasons = [];
            
            // Advisory ID extracted (+40)
            maxScore += 40;
            if (poam.advisoryIds.length > 0) {
                score += 40;
            } else {
                reviewReasons.push('No advisory IDs extracted');
            }
            
            // Fixed target extracted (+30)
            maxScore += 30;
            if (poam.fixedTarget && poam.fixedTargetKey !== 'unknown') {
                score += 30;
            } else {
                reviewReasons.push('Fixed target not clearly identified');
            }
            
            // Remediation type confidently classified (+20)
            maxScore += 20;
            if (poam.remediationType !== 'unknown' && poam.remediationType !== 'no_action_unknown') {
                score += 20;
            } else {
                reviewReasons.push('Remediation type unclear');
            }
            
            // Component dictionary match (+15)
            maxScore += 15;
            if (this.componentDictionary[poam.component.toLowerCase()]) {
                score += 15;
            } else {
                reviewReasons.push('Component not in known dictionary');
            }
            
            // Current evidence extracted (+10)
            maxScore += 10;
            if (poam.evidenceSamples.length > 0) {
                score += 10;
            } else {
                reviewReasons.push('No evidence samples available');
            }
            
            // Calculate final score
            poam.confidenceScore = Math.round((score / maxScore) * 100);
            
            // Determine confidence level
            if (poam.confidenceScore >= 80) {
                poam.confidenceLevel = 'High';
            } else if (poam.confidenceScore >= 60) {
                poam.confidenceLevel = 'Medium';
            } else {
                poam.confidenceLevel = 'Low';
            }
            
            // Enhanced needsReview logic
            let needsReview = false;
            
            // Rule 1: Confidence score < 70
            if (poam.confidenceScore < 70) {
                needsReview = true;
                if (!reviewReasons.includes('Low confidence score')) {
                    reviewReasons.push('Low confidence score');
                }
            }
            
            // Rule 2: Windows patch cycle missing
            if (poam.remediationType === 'patch_cycle' && 
                poam.platform === 'windows' && 
                !poam.fixedTarget?.patchCycle) {
                needsReview = true;
                reviewReasons.push('Windows patch cycle date not detected');
            }
            
            // Rule 3: Conflicting fixed targets detected
            if (this.hasConflictingTargets(poam)) {
                needsReview = true;
                reviewReasons.push('Conflicting fixed targets detected in findings');
            }
            
            // Rule 4: Unassigned POC
            if (poam.pocTeam === 'Unassigned') {
                needsReview = true;
                reviewReasons.push('No POC team assigned');
            }
            
            // Rule 5: Missing raw scan data
            if (!poam.rawFindings || poam.rawFindings.length === 0) {
                needsReview = true;
                reviewReasons.push('No raw scan data available');
                console.warn(`âš ï¸ POAM ${poam.id} missing rawFindings - needs review`);
            }
            
            // Rule 6: Description indicates error
            if (poam.description && poam.description.includes('ERROR: No raw scan data')) {
                needsReview = true;
                if (!reviewReasons.includes('No raw scan data available')) {
                    reviewReasons.push('No raw scan data available');
                }
                console.warn(`âš ï¸ POAM ${poam.id} has error in description - needs review`);
            }
            
            // Rule 7: No affected assets extracted
            if (!poam.affectedAssets || poam.affectedAssets.length === 0) {
                needsReview = true;
                reviewReasons.push('No affected assets could be extracted from scan data');
                console.warn(`âš ï¸ POAM ${poam.id} has no affected assets - missing required Qualys columns`);
            }
            
            // Rule 8: Asset count mismatch
            if (poam.affectedAssets && poam.totalAffectedAssets !== poam.affectedAssets.length) {
                console.warn(`âš ï¸ POAM ${poam.id} asset count mismatch: totalAffectedAssets=${poam.totalAffectedAssets}, actual=${poam.affectedAssets.length}`);
                // Update to match actual
                poam.totalAffectedAssets = poam.affectedAssets.length;
            }
            
            poam.needsReview = needsReview;
            poam.reviewReasons = reviewReasons;
        });
    }
    
    hasConflictingTargets(poam) {
        // Check if raw findings have significantly different fixed targets
        if (!poam.rawFindings || poam.rawFindings.length < 2) return false;
        
        const targets = new Set();
        poam.rawFindings.forEach(f => {
            const target = f.remediation?.fixedTarget?.version || 
                          f.remediation?.fixedTarget?.patchCycle ||
                          f.remediation?.fixedTargetKey;
            if (target && target !== 'unknown' && target !== 'latest') {
                targets.add(target);
            }
        });
        
        // If more than 2 different specific targets, flag as conflicting
        return targets.size > 2;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // POC ASSIGNMENT RULES ENGINE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    assignPOC(remediation, group) {
        // Precedence: 1) Asset tags, 2) OS from scan data, 3) Platform, 4) Component class, 5) Fallback
        
        // 1) Check for explicit asset tags or boundary ownership (highest priority)
        const assetTagMatch = this.checkAssetTagRules(group.findings);
        if (assetTagMatch) {
            return {
                pocTeam: assetTagMatch.team,
                assignmentReason: `asset_tag=${assetTagMatch.tag}`,
                ruleMatched: 'Asset Tag Rule',
                precedence: 1
            };
        }
        
        // 2) OS-based assignment from raw scan data (NEW - highest priority for patching)
        const osMatch = this.checkOSRules(group.findings);
        if (osMatch) {
            return {
                pocTeam: osMatch.team,
                assignmentReason: `os=${osMatch.os}`,
                ruleMatched: 'OS-Based Rule',
                precedence: 2
            };
        }
        
        // 3) Platform-based assignment
        const platformMatch = this.checkPlatformRules(remediation);
        if (platformMatch) {
            return {
                pocTeam: platformMatch.team,
                assignmentReason: `platform=${remediation.platform}`,
                ruleMatched: 'Platform Rule',
                precedence: 3
            };
        }
        
        // 4) Component class assignment
        const componentMatch = this.checkComponentRules(remediation);
        if (componentMatch) {
            return {
                pocTeam: componentMatch.team,
                assignmentReason: `component=${remediation.component}`,
                ruleMatched: 'Component Rule',
                precedence: 4
            };
        }
        
        // 5) Fallback - flag as unassigned priority
        return {
            pocTeam: 'Unassigned',
            assignmentReason: 'no_matching_rule',
            ruleMatched: 'Fallback',
            precedence: 99,
            flagAsPriority: true
        };
    }
    
    checkOSRules(findings) {
        // Extract OS from raw scan data (Qualys 'OS' column)
        const osSamples = findings
            .map(f => f['OS'] || f['Operating System'] || f.os || '')
            .filter(os => os && os.trim())
            .slice(0, 10); // Check first 10 findings
        
        if (osSamples.length === 0) {
            return null; // No OS data available
        }
        
        // Get most common OS
        const osLower = osSamples[0].toLowerCase();
        
        // Windows detection
        if (osLower.includes('windows')) {
            console.log(`âœ… Auto-assigned to Windows Systems Team based on OS: ${osSamples[0]}`);
            return { team: 'Windows Systems Team', os: osSamples[0] };
        }
        
        // Linux detection
        if (osLower.includes('linux') || osLower.includes('ubuntu') || 
            osLower.includes('centos') || osLower.includes('rhel') || 
            osLower.includes('red hat') || osLower.includes('debian') ||
            osLower.includes('suse') || osLower.includes('fedora')) {
            console.log(`âœ… Auto-assigned to Linux Systems Team based on OS: ${osSamples[0]}`);
            return { team: 'Linux Systems Team', os: osSamples[0] };
        }
        
        // Unix detection
        if (osLower.includes('unix') || osLower.includes('solaris') || 
            osLower.includes('aix') || osLower.includes('hp-ux')) {
            console.log(`âœ… Auto-assigned to Unix Systems Team based on OS: ${osSamples[0]}`);
            return { team: 'Unix Systems Team', os: osSamples[0] };
        }
        
        // macOS detection
        if (osLower.includes('mac') || osLower.includes('darwin') || osLower.includes('osx')) {
            console.log(`âœ… Auto-assigned to End User Computing Team based on OS: ${osSamples[0]}`);
            return { team: 'End User Computing Team', os: osSamples[0] };
        }
        
        return null;
    }
    
    checkAssetTagRules(findings) {
        // Check for asset tags in findings
        for (const finding of findings.slice(0, 10)) {
            const tags = finding.assetTags || finding.asset?.assetTags || '';
            const tagsLower = tags.toLowerCase();
            
            if (tagsLower.includes('dmz') || tagsLower.includes('boundary')) {
                return { team: 'Network Security Team', tag: 'DMZ/Boundary' };
            }
            if (tagsLower.includes('pci') || tagsLower.includes('cardholder')) {
                return { team: 'PCI Compliance Team', tag: 'PCI' };
            }
            if (tagsLower.includes('critical') || tagsLower.includes('tier1')) {
                return { team: 'Critical Systems Team', tag: 'Critical/Tier1' };
            }
        }
        return null;
    }
    
    checkPlatformRules(remediation) {
        const platform = remediation.platform;
        const component = remediation.component;
        
        // Windows endpoint vs server distinction
        if (platform === 'windows') {
            // Check if it's endpoint software (browsers, etc.)
            if (['firefox', 'chrome', 'edge', 'safari'].includes(component)) {
                return { team: 'End User Computing Team' };
            }
            // Server components
            return { team: 'Windows Systems Team' };
        }
        
        if (platform === 'linux') {
            return { team: 'Linux Systems Team' };
        }
        
        if (platform === 'network') {
            return { team: 'Network Engineering Team' };
        }
        
        return null;
    }
    
    checkComponentRules(remediation) {
        const component = remediation.component;
        
        // Browsers
        if (['firefox', 'chrome', 'edge', 'safari'].includes(component)) {
            return { team: 'Desktop Engineering Team' };
        }
        
        // Application frameworks
        if (['java', 'dotnet', 'python', 'nodejs', 'spring_framework'].includes(component)) {
            return { team: 'Application Development Team' };
        }
        
        // Web servers
        if (['apache', 'nginx', 'iis', 'tomcat'].includes(component)) {
            return { team: 'Web Infrastructure Team' };
        }
        
        // Network/security components
        if (['openssh', 'ssl', 'tls'].includes(component)) {
            return { team: 'Network Security Team' };
        }
        
        return null;
    }
    
    evaluateRuleConditions(conditions, remediation, group) {
        if (!conditions || Object.keys(conditions).length === 0) return false;
        
        let matches = true;
        
        if (conditions.platform) {
            matches = matches && conditions.platform.includes(remediation.platform);
        }
        if (conditions.remediationType) {
            matches = matches && conditions.remediationType.includes(remediation.remediationType);
        }
        if (conditions.component) {
            matches = matches && conditions.component.includes(remediation.component);
        }
        
        return matches;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SMART POAM DESCRIPTIONS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    generateSmartDescription(remediation, group, breachAnalysis) {
        console.log('ğŸ“ Generating description using raw scan data (NO templates or summaries)');
        
        if (!group.findings || group.findings.length === 0) {
            console.error('âŒ No rawFindings available - setting needsReview flag');
            return 'ERROR: No raw scan data available. This POAM needs review.';
        }
        
        // For single finding POAMs, use raw data directly
        if (group.findings.length === 1) {
            const finding = group.findings[0];
            console.log('ğŸ“ Single finding - using raw scan fields in priority order');
            
            // Priority order: Results > CVE-Description > Description > Title
            const description = finding.results || 
                               finding['CVE-Description'] || 
                               finding.description || 
                               finding.title || 
                               'No description available in scan data';
            
            console.log('âœ… Using field:', finding.results ? 'Results' : 
                       finding['CVE-Description'] ? 'CVE-Description' : 
                       finding.description ? 'Description' : 'Title');
            
            return description;
        }
        
        // For grouped POAMs, build structured roll-up from rawFindings
        console.log(`ğŸ“ Grouped POAM (${group.findings.length} findings) - building structured roll-up`);
        
        const firstFinding = group.findings[0];
        const title = firstFinding.title || 'Vulnerability';
        
        // Get 1-3 representative Results snippets
        const resultsSnippets = group.findings
            .map(f => f.results)
            .filter(r => r && r.trim() && r !== 'N/A')
            .slice(0, 3);
        
        // Get impact from CVE-Description or Title
        const impact = firstFinding['CVE-Description'] || 
                      firstFinding.description || 
                      firstFinding.title || 
                      'Impact details not available';
        
        // Build structured description
        let structuredDesc = `${title}\n\n`;
        
        if (resultsSnippets.length > 0) {
            structuredDesc += `Evidence from scan:\n`;
            resultsSnippets.forEach((snippet, idx) => {
                const truncated = snippet.length > 200 ? snippet.substring(0, 200) + '...' : snippet;
                structuredDesc += `${idx + 1}. ${truncated}\n`;
            });
            structuredDesc += `\n`;
        }
        
        structuredDesc += `Impact: ${impact}\n\n`;
        structuredDesc += `Source: Qualys Vulnerability Scan Report`;
        
        console.log('âœ… Built structured roll-up from raw scan data');
        return structuredDesc;
    }
    
    // Separate function to get affected assets for the dedicated tab/section
    getAffectedAssetsForDisplay(group) {
        console.log('ğŸ¢ Extracting affected assets for dedicated display');
        const affectedAssets = this.extractAffectedAssets(group.findings);
        console.log('ğŸ” Affected assets for display:', affectedAssets.length, 'assets');
        return affectedAssets;
    }
    
    extractAffectedAssets(findings) {
        const assetMap = new Map();
        
        findings.forEach((finding, index) => {
            // Extract asset using CSV processor output fields
            const assetName = finding.host || 
                             finding.asset?.hostname ||
                             finding.asset?.assetId || 
                             finding.ip ||
                             'Unknown';
            
            const assetId = finding.asset?.assetId || '';
            const ipv4 = finding.ip || finding.asset?.ipv4 || '';
            const os = finding.asset?.operatingSystem || '';
            
            // Create asset entry with full details
            if (assetName !== 'Unknown') {
                const assetKey = assetName;
                if (!assetMap.has(assetKey)) {
                    assetMap.set(assetKey, {
                        assetName: assetName,
                        assetId: assetId,
                        ipv4: ipv4,
                        os: os,
                        // Keep legacy fields for backward compatibility
                        hostname: assetName,
                        ip: ipv4,
                        name: assetName, // For UI compatibility
                        operatingSystem: os // For UI compatibility
                    });
                }
            }
        });
        
        return Array.from(assetMap.values());
    }
    
    extractAllCVEs(findings) {
        const cves = new Set();
        findings.forEach(finding => {
            if (finding.cve) {
                let cveList = [];
                
                // Handle array input from QualysProcessor (already parsed)
                if (Array.isArray(finding.cve)) {
                    cveList = finding.cve;
                }
                // Handle string input (legacy format)
                else if (typeof finding.cve === 'string') {
                    cveList = finding.cve.split(',').map(cve => cve.trim());
                }
                
                cveList.forEach(cve => {
                    if (cve && cve.startsWith('CVE-')) {
                        cves.add(cve);
                    }
                });
            }
        });
        return Array.from(cves);
    }
    
    extractNISTControls(remediation) {
        const controls = [];
        if (remediation.impactedControls) {
            controls.push(...remediation.impactedControls);
        }
        return controls;
    }
    
    generateDescriptionSummary(remediation, componentTitle, group) {
        switch (remediation.remediationType) {
            case 'patch_cycle':
                if (remediation.platform === 'windows' && remediation.fixedTarget?.patchCycle) {
                    return `Windows ${remediation.fixedTarget.patchCycle} Security Updates are missing on the affected assets.`;
                }
                return `${componentTitle} security updates are missing on the affected assets.`;
                
            case 'kb_install':
                const kbIds = remediation.fixedTarget?.kbIds?.join(', ') || 'KB updates';
                return `Windows ${kbIds} are missing on the affected assets.`;
                
            case 'software_upgrade':
                if (remediation.targetingStrategy === 'latest_supported') {
                    return `${componentTitle} is below the approved latest release on the affected assets, resulting in multiple vulnerabilities.`;
                } else {
                    const targetVersion = remediation.fixedTarget?.version || remediation.fixedTargetKey;
                    return `${componentTitle} requires upgrade to version ${targetVersion} on the affected assets to address multiple vulnerabilities.`;
                }
                
            case 'vendor_fix':
                return `${componentTitle} requires vendor-provided security fix on the affected assets.`;
                
            case 'config_change':
                return `${componentTitle} configuration hardening is required on the affected assets.`;
                
            case 'operational_mitigation':
                return `${componentTitle} requires operational mitigation controls as no vendor patch is available.`;
                
            case 'package_upgrade':
                return `${componentTitle} package requires update on the affected assets.`;
                
            default:
                return `${componentTitle} requires remediation on the affected assets.`;
        }
    }
    
    generateRemediationAction(remediation, componentTitle, group) {
        switch (remediation.remediationType) {
            case 'patch_cycle':
                if (remediation.platform === 'windows' && remediation.fixedTarget?.patchCycle) {
                    return `Deploy the Windows ${remediation.fixedTarget.patchCycle} cumulative security updates to all affected assets using the standard Windows patch deployment process (WSUS/SCCM/Intune).`;
                }
                return `Deploy the latest security patches to all affected ${remediation.platform} systems using the standard patch management process.`;
                
            case 'kb_install':
                const kbIds = remediation.fixedTarget?.kbIds?.join(', ') || 'the required KB updates';
                return `Install ${kbIds} on all affected Windows systems using the standard Windows update deployment process.`;
                
            case 'software_upgrade':
                if (remediation.targetingStrategy === 'latest_supported') {
                    return `Upgrade ${componentTitle} to the approved latest release using the standard endpoint deployment process. Verify the approved version with the Change Advisory Board before deployment.`;
                } else {
                    const targetVersion = remediation.fixedTarget?.version || remediation.fixedTargetKey;
                    return `Upgrade ${componentTitle} to version ${targetVersion} or later using the standard application deployment process.`;
                }
                
            case 'vendor_fix':
                const advisory = Array.from(group.advisoryIds)[0] || 'vendor advisory';
                return `Apply the vendor-provided security fix per ${advisory} documentation. Follow vendor-specific installation procedures.`;
                
            case 'config_change':
                return `Apply the recommended configuration hardening per organizational security baseline. Document configuration changes in the change management system.`;
                
            case 'operational_mitigation':
                return `Implement compensating controls including: network segmentation to limit exposure, access restrictions via firewall rules or ACLs, enhanced monitoring and alerting for exploitation attempts. Document mitigation controls and monitor for vendor patch availability.`;
                
            case 'package_upgrade':
                const targetVersion = remediation.fixedTarget?.version || 'latest';
                return `Update ${componentTitle} package to version ${targetVersion} using the system package manager (yum/apt/dnf). Test in non-production environment before production deployment.`;
                
            default:
                return `Remediate ${componentTitle} vulnerabilities per vendor guidance and organizational security standards.`;
        }
    }
    
    generateValidationMethod(remediation, componentTitle) {
        switch (remediation.remediationType) {
            case 'patch_cycle':
            case 'kb_install':
            case 'software_upgrade':
            case 'package_upgrade':
                return `Validation will be performed by rescanning affected assets using the vulnerability scanner and confirming that ${componentTitle} findings are resolved. Verify that the installed version meets or exceeds the required version.`;
                
            case 'vendor_fix':
                return `Validation will be performed by rescanning affected assets and confirming that the vendor advisory findings are cleared. Verify fix installation through system evidence (installed packages, version checks).`;
                
            case 'config_change':
                return `Validation will be performed by rescanning affected assets and confirming that configuration findings are resolved. Verify configuration changes through system audits and compliance scans.`;
                
            case 'operational_mitigation':
                return `Validation will be performed by verifying that compensating controls are in place and effective. Document control implementation and maintain monitoring for vendor patch availability. Rescan to confirm no new exploitation attempts.`;
                
            default:
                return `Validation will be performed by rescanning affected assets and confirming that findings are resolved.`;
        }
    }
    
    getLatestDetectionDate(findings) {
        let latest = null;
        findings.forEach(f => {
            const lastDetected = f.sla?.lastDetected;
            if (lastDetected) {
                if (!latest || lastDetected > latest) {
                    latest = lastDetected;
                }
            }
        });
        return latest || 'Unknown';
    }
    
    getDescriptionTemplate(remediation) {
        const templateKey = remediation.remediationType === 'software_upgrade' ?
            (remediation.targetingStrategy === 'latest_supported' ? 
                'software_upgrade_latest' : 'software_upgrade_branched') :
            remediation.remediationType;
        
        const templates = {
            patch_cycle: "Apply {platform} security patches for {patchCycle}.\n\nAffected Systems: {assetCount} assets\nSeverity: {severity}\nFirst Detected: {firstDetected}\nSLA Breach Date: {breachDate}\n\nThis POAM consolidates {findingCount} findings that require the {patchCycle} patch cycle to be applied.\n\nSample CVEs: {sampleCVEs}\nSample Advisories: {sampleAdvisories}\n\nRemediation Action: Deploy {patchCycle} patches to all affected {platform} systems.",
            
            kb_install: "Install KB updates for {component}.\n\nAffected Systems: {assetCount} assets\nSeverity: {severity}\nKB Updates Required: {kbIds}\nFirst Detected: {firstDetected}\nSLA Breach Date: {breachDate}\n\nThis POAM consolidates {findingCount} findings requiring KB installation.\n\nSample CVEs: {sampleCVEs}\n\nRemediation Action: Install the following KB updates: {kbIds}",
            
            software_upgrade_latest: "Upgrade {component} to approved latest version on {platform} systems.\n\nAffected Systems: {assetCount} assets\nSeverity: {severity}\nCurrent Versions Detected: {currentVersions}\nTarget: Latest approved version\nFirst Detected: {firstDetected}\nSLA Breach Date: {breachDate}\n\nThis POAM consolidates {findingCount} findings across multiple CVEs that are all resolved by upgrading {component} to the latest approved version.\n\nSample CVEs: {sampleCVEs}\nSample Advisories: {sampleAdvisories}\n\nRemediation Action: Upgrade all instances of {component} to the latest approved version per organizational standards.",
            
            software_upgrade_branched: "Upgrade {component} to version {targetVersion} on {platform} systems.\n\nAffected Systems: {assetCount} assets\nSeverity: {severity}\nCurrent Versions Detected: {currentVersions}\nTarget Version: {targetVersion}\nFirst Detected: {firstDetected}\nSLA Breach Date: {breachDate}\n\nThis POAM consolidates {findingCount} findings for {component} version {majorVersion} track.\n\nSample CVEs: {sampleCVEs}\n\nRemediation Action: Upgrade {component} to version {targetVersion} or later within the {majorVersion} support track.",
            
            vendor_fix: "Apply vendor security fix per advisory {advisoryIds}.\n\nAffected Systems: {assetCount} assets\nSeverity: {severity}\nComponent: {component}\nAdvisory IDs: {advisoryIds}\nFirst Detected: {firstDetected}\nSLA Breach Date: {breachDate}\n\nThis POAM consolidates {findingCount} findings addressed by vendor advisory {advisoryIds}.\n\nSample CVEs: {sampleCVEs}\n\nRemediation Action: Apply vendor-provided fix per advisory documentation.",
            
            operational_mitigation: "Implement operational mitigation for {component} (no patch available).\n\nAffected Systems: {assetCount} assets\nSeverity: {severity}\nComponent: {component}\nFirst Detected: {firstDetected}\nSLA Breach Date: {breachDate}\n\nThis POAM consolidates {findingCount} findings with no vendor patch available.\n\nSample CVEs: {sampleCVEs}\n\nRemediation Action: Implement compensating controls such as network segmentation, access restrictions, or monitoring until vendor provides a patch.\n\nEvidence Samples:\n{evidenceSamples}",
            
            package_upgrade: "Update {component} package to version {targetVersion} on {platform} systems.\n\nAffected Systems: {assetCount} assets\nSeverity: {severity}\nCurrent Versions: {currentVersions}\nTarget Version: {targetVersion}\nFirst Detected: {firstDetected}\nSLA Breach Date: {breachDate}\n\nThis POAM consolidates {findingCount} findings for {component} package updates.\n\nSample CVEs: {sampleCVEs}\n\nRemediation Action: Update {component} package using system package manager (yum/apt/dnf)."
        };
        
        return templates[templateKey] || templates.software_upgrade_latest;
    }
    
    selectPOAMTitle(remediation, group, breachAnalysis) {
        // CRITICAL: Titles MUST come from scanner-provided vulnerability titles
        // Do NOT generate synthetic remediation prose
        
        const titles = group.findings.map(f => f.text?.title || '').filter(t => t);
        
        if (titles.length === 0) {
            return 'Unknown Vulnerability (No title provided by scanner)';
        }
        
        // Rule 1: If all findings share the same exact title, use it verbatim
        const uniqueTitles = [...new Set(titles)];
        if (uniqueTitles.length === 1) {
            return uniqueTitles[0];
        }
        
        // Rule 2: For latest_supported components, use dominant common prefix
        if (remediation.targetingStrategy === 'latest_supported') {
            const commonPrefix = this.findCommonPrefix(titles);
            if (commonPrefix && commonPrefix.length > 10) {
                // Use common prefix with "Multiple Vulnerabilities" suffix
                return `${commonPrefix.trim()} Multiple Vulnerabilities`;
            }
        }
        
        // Rule 3: Windows patch cycle - retain exact month-based titles
        if (remediation.remediationType === 'patch_cycle' && remediation.platform === 'windows') {
            // Look for month/year pattern in titles
            const patchTitle = titles.find(t => t.match(/\b(20\d{2})[-\s](0[1-9]|1[0-2])\b/) || 
                                                  t.match(/\b(January|February|March|April|May|June|July|August|September|October|November|December)\s+(20\d{2})\b/i));
            if (patchTitle) {
                return patchTitle;
            }
            // Fallback: use most common title
            return this.getMostCommonTitle(titles);
        }
        
        // Rule 4: Configuration and exposure findings - retain exact scanner titles
        if (remediation.remediationType === 'config_change' || 
            remediation.remediationType === 'operational_mitigation') {
            // Use the most common title (likely the canonical one)
            return this.getMostCommonTitle(titles);
        }
        
        // Rule 5: For other cases, use most common title
        return this.getMostCommonTitle(titles);
    }
    
    findCommonPrefix(titles) {
        if (titles.length === 0) return '';
        if (titles.length === 1) return titles[0];
        
        // Find longest common prefix
        let prefix = titles[0];
        for (let i = 1; i < titles.length; i++) {
            while (titles[i].indexOf(prefix) !== 0) {
                prefix = prefix.substring(0, prefix.length - 1);
                if (prefix === '') return '';
            }
        }
        
        // Trim to last complete word
        const lastSpace = prefix.lastIndexOf(' ');
        if (lastSpace > 0) {
            prefix = prefix.substring(0, lastSpace);
        }
        
        return prefix;
    }
    
    getMostCommonTitle(titles) {
        // Count occurrences of each title
        const counts = {};
        titles.forEach(title => {
            counts[title] = (counts[title] || 0) + 1;
        });
        
        // Return most common
        let maxCount = 0;
        let mostCommon = titles[0];
        Object.entries(counts).forEach(([title, count]) => {
            if (count > maxCount) {
                maxCount = count;
                mostCommon = title;
            }
        });
        
        return mostCommon;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // HELPER FUNCTIONS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    parseDate(dateString) {
        if (!dateString) return null;
        const date = new Date(dateString);
        return isNaN(date.getTime()) ? null : date;
    }
    
    daysBetween(date1, date2) {
        const msPerDay = 1000 * 60 * 60 * 24;
        return Math.floor((date2 - date1) / msPerDay);
    }
    
    addDays(date, days) {
        const result = new Date(date);
        result.setDate(result.getDate() + days);
        return result;
    }
    
    normalizeSeverity(severity) {
        if (!severity) return 'medium';
        const sev = severity.toLowerCase();
        if (sev.includes('critical') || sev === '5') return 'critical';
        if (sev.includes('high') || sev === '4') return 'high';
        if (sev.includes('medium') || sev === '3') return 'medium';
        if (sev.includes('low') || sev === '2' || sev === '1') return 'low';
        return 'medium';
    }
    
    isHigherRisk(risk1, risk2) {
        const levels = { critical: 4, high: 3, medium: 2, low: 1 };
        return (levels[risk1] || 0) > (levels[risk2] || 0);
    }
    
    extractUniqueVersions(findings) {
        const versions = new Set();
        findings.forEach(f => {
            if (f.evidence?.currentVersion) {
                versions.add(f.evidence.currentVersion);
            }
        });
        return Array.from(versions).slice(0, 5);
    }
    
    determinePOAMStatus(remediation, breachAnalysis, group) {
        // POAM status logic:
        // - Open: breachedAssets exist and activeAssets exist
        // - Closed: no activeAssets remain
        // - Mitigation: remediationType == operational_mitigation
        // - Risk Accepted: remediationType == risk_acceptance OR CSV status = "yes"
        
        // Check CSV status field (Column V) and Ignored field - if any finding has status "yes" or Ignored="Yes", set to risk-accepted
        if (group && group.findings) {
            const hasRiskAcceptedStatus = group.findings.some(finding => {
                const status = (finding.status || '').toLowerCase().trim();
                const isIgnored = finding.ignored === true; // Qualys 'Ignored' column
                return status === 'yes' || status === 'risk accepted' || status === 'risk-accepted' || isIgnored;
            });
            
            if (hasRiskAcceptedStatus) {
                const ignoredCount = group.findings.filter(f => f.ignored === true).length;
                console.log(`ğŸ” Risk-accepted status detected in CSV for group with ${group.findings.length} findings (${ignoredCount} ignored)`);
                return 'risk-accepted';
            }
        }
        
        if (remediation.remediationType === 'operational_mitigation') {
            return 'mitigation';
        }
        
        if (remediation.remediationType === 'risk_acceptance') {
            return 'risk_accepted';
        }
        
        if (breachAnalysis.activeAssets.size === 0) {
            return 'closed';
        }
        
        return 'open';
    }
    
    getTitleSelectionRule(remediation, group) {
        // Return which title SELECTION rule was used for debugging
        const titles = group.findings.map(f => f.text?.title || '').filter(t => t);
        const uniqueTitles = [...new Set(titles)];
        
        if (titles.length === 0) {
            return 'No scanner titles available';
        }
        
        if (uniqueTitles.length === 1) {
            return 'Single exact title (used verbatim)';
        }
        
        if (remediation.targetingStrategy === 'latest_supported') {
            return 'Latest-supported component (common prefix + Multiple Vulnerabilities)';
        }
        
        if (remediation.remediationType === 'patch_cycle' && remediation.platform === 'windows') {
            return 'Windows patch cycle (month-based title from scanner)';
        }
        
        if (remediation.remediationType === 'config_change' || 
            remediation.remediationType === 'operational_mitigation') {
            return 'Configuration/mitigation (most common scanner title)';
        }
        
        return 'Most common scanner title selected';
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DESCRIPTION NORMALIZATION HELPERS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    normalizeText(s) {
        if (!s) return "";
        const t = String(s).trim();
        const junk = new Set(["-", "â€“", "â€”", "n/a", "na", "none", "null", "unknown", ""]);
        if (junk.has(t.toLowerCase())) return "";
        if (t.length < 5) return "";
        return t;
    }

    severityRank(sev) {
        // Higher is worse
        const map = { critical: 5, high: 4, medium: 3, low: 2, info: 1 };
        if (typeof sev === "number") return sev;
        return map[String(sev || "").toLowerCase()] ?? 0;
    }

    computeFindingDescriptionDisplay(groupFindings, groupTitle) {
        console.log(`ğŸ” Computing description for group with ${groupFindings?.length || 0} findings`);
        
        const findings = (groupFindings || []).map(f => ({
            ...f,
            cleanDesc: this.normalizeText(f.description),
            cleanTitle: this.normalizeText(f.title),
            sevRank: this.severityRank(f.severity),
            cveCount: Array.isArray(f.cve) ? f.cve.length : 0
        }));

        // Log first few findings for debugging
        if (findings.length > 0) {
            console.log(`ğŸ“ Sample finding data:`, {
                rawDesc: findings[0].description?.substring(0, 100),
                cleanDesc: findings[0].cleanDesc?.substring(0, 100),
                rawTitle: findings[0].title?.substring(0, 100),
                cleanTitle: findings[0].cleanTitle?.substring(0, 100),
                severity: findings[0].severity,
                sevRank: findings[0].sevRank
            });
        }

        const candidates = findings.filter(f => f.cleanDesc);
        console.log(`âœ… Found ${candidates.length} findings with clean descriptions out of ${findings.length} total`);

        // Priority 1: highest severity with a real description
        candidates.sort((a, b) =>
            (b.sevRank - a.sevRank) ||
            (b.cveCount - a.cveCount)
        );

        if (candidates.length > 0) {
            console.log(`âœ… Using description from severity ${candidates[0].severity} finding: ${candidates[0].cleanDesc.substring(0, 100)}...`);
            return candidates[0].cleanDesc;
        }

        // Priority 2: fallback to a meaningful title with count summary
        const cleanGroupTitle = this.normalizeText(groupTitle) || this.normalizeText(findings[0]?.title) || "Vulnerability group";
        const uniqueCves = new Set(findings.flatMap(f => Array.isArray(f.cve) ? f.cve : []));
        const fallback = `${cleanGroupTitle}. This POAM groups ${findings.length} findings across ${uniqueCves.size} CVEs.`;
        console.log(`âš ï¸ No clean descriptions found, using fallback: ${fallback}`);
        return fallback;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SCAN SUMMARY CREATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    createScanSummary(poamId, group, remediation) {
        console.log(`ğŸ“¸ Creating scan summary for POAM ${poamId} with ${group.findings.length} findings`);
        
        // Extract affected assets from raw Qualys CSV columns
        const affectedAssets = [];
        const assetMap = new Map(); // Use Map to deduplicate by asset name
        
        // Log first finding to show available fields from CSV processor
        if (group.findings.length > 0) {
            const firstFinding = group.findings[0];
            console.log(`ğŸ” Available fields:`, Object.keys(firstFinding));
            console.log(`ğŸ” Sample values:`, {
                'host': firstFinding.host,
                'ip': firstFinding.ip,
                'asset.hostname': firstFinding.asset?.hostname,
                'asset.assetId': firstFinding.asset?.assetId,
                'asset.ipv4': firstFinding.asset?.ipv4,
                'asset.operatingSystem': firstFinding.asset?.operatingSystem
            });
        }
        
        group.findings.forEach((finding, index) => {
            // Extract asset using CSV processor output fields
            const assetName = finding.host || 
                             finding.asset?.hostname ||
                             finding.asset?.assetId || 
                             finding.ip ||
                             'Unknown';
            
            const assetId = finding.asset?.assetId || '';
            const ipv4 = finding.ip || finding.asset?.ipv4 || '';
            const os = finding.asset?.operatingSystem || '';
            
            // Log first few asset extractions
            if (index < 3) {
                console.log(`ğŸ¢ Asset ${index + 1}:`, {
                    assetName,
                    assetId,
                    ipv4,
                    os
                });
            }
            
            // Create asset entry with full details
            if (assetName !== 'Unknown') {
                const assetKey = assetName; // Dedupe by asset name
                if (!assetMap.has(assetKey)) {
                    assetMap.set(assetKey, {
                        assetName: assetName,
                        assetId: assetId,
                        ipv4: ipv4,
                        os: os,
                        // Keep legacy fields for backward compatibility
                        hostname: assetName,
                        ip: ipv4
                    });
                }
            } else {
                console.warn(`âš ï¸ Could not extract asset name from finding ${index + 1}`);
            }
        });
        
        // Convert to array
        affectedAssets.push(...Array.from(assetMap.values()));
        console.log(`âœ… Extracted ${affectedAssets.length} unique assets from ${group.findings.length} findings`);
        
        // Warn if no assets were extracted
        if (affectedAssets.length === 0) {
            console.error(`âŒ No assets extracted for POAM ${poamId} - missing required Qualys columns`);
        }
        
        // Extract solution text from Qualys 'Solution' column (most common or first non-empty)
        const solutions = group.findings
            .map(f => f.solution) // Use exact Qualys 'Solution' column
            .filter(s => s && s.trim() !== '' && s !== 'No solution available');
        const solutionText = solutions.length > 0 ? 
            this.getMostCommonValue(solutions) : 'No solution available';
        
        // Compute finding description using severity-based priority (computed once, stored once)
        const findingDescriptionDisplay = this.computeFindingDescriptionDisplay(
            group.findings, 
            remediation.actionText || group.findings[0]?.title
        );
        
        console.log(`ğŸ“ Computed description for ${poamId}: ${findingDescriptionDisplay.substring(0, 100)}...`);
        
        // Extract sample results for audit evidence (from 'Results' column)
        const results = group.findings
            .map(f => f.results || f.evidence) // Use Qualys 'Results' column
            .filter(r => r && r.trim() !== '');
        const resultsSamples = results.slice(0, 3); // Take first 3 samples
        
        // Extract detection dates if available
        const dates = group.findings
            .map(f => f['first detected'] || f['last detected'] || f.date || f.detected)
            .filter(d => d && d.trim() !== '');
        
        let firstDetectedMin = null;
        let lastDetectedMax = null;
        
        if (dates.length > 0) {
            const parsedDates = dates
                .map(d => new Date(d))
                .filter(d => !isNaN(d.getTime()));
            
            if (parsedDates.length > 0) {
                firstDetectedMin = new Date(Math.min(...parsedDates)).toISOString();
                lastDetectedMax = new Date(Math.max(...parsedDates)).toISOString();
            }
        }
        
        const scanSummary = {
            id: `${poamId}_${this.scanId}`, // Composite key required by IndexedDB
            poamId: poamId,
            scanId: this.scanId,
            rawFindings: group.findings, // Store raw findings for this POAM
            affectedAssets: affectedAssets,
            totalAffectedAssets: affectedAssets.length,
            finding_description_display: findingDescriptionDisplay, // Computed once using severity-based priority
            solutionText: solutionText, // Exact solution from Qualys Solution column
            firstDetectedMin: firstDetectedMin,
            lastDetectedMax: lastDetectedMax,
            resultsSamples: resultsSamples,
            createdAt: new Date().toISOString()
        };
        
        console.log(`âœ… Created scan summary for ${poamId}: ${affectedAssets.length} assets, ${resultsSamples.length} result samples`);
        return scanSummary;
    }

    async saveScanSummary(scanSummary) {
        try {
            await poamDB.savePoamScanSummary(scanSummary);
            console.log(`ğŸ’¾ Saved scan summary for POAM ${scanSummary.poamId}`);
        } catch (error) {
            console.error(`âŒ Failed to save scan summary for POAM ${scanSummary.poamId}:`, error);
        }
    }

    getMostCommonValue(arr) {
        const frequency = {};
        let maxCount = 0;
        let mostCommon = arr[0];
        
        arr.forEach(item => {
            frequency[item] = (frequency[item] || 0) + 1;
            if (frequency[item] > maxCount) {
                maxCount = frequency[item];
                mostCommon = item;
            }
        });
        
        return mostCommon;
    }
}

// Export for use
if (typeof module !== 'undefined' && module.exports) {
    module.exports = VulnerabilityAnalysisEngineV3;
}
