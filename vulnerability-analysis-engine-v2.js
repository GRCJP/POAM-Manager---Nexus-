// Enhanced Vulnerability Analysis Engine V2
// Remediation-First POAM Grouping System
// Converts raw vulnerability scanner CSV exports into actionable POAMs

console.log('âœ… vulnerability-analysis-engine-v2.js loaded successfully');

class VulnerabilityAnalysisEngineV2 {
    constructor() {
        this.vulnerabilities = [];
        this.groupedPOAMs = [];
        this.debugCount = 0;
        
        // Component normalization dictionary
        this.componentDictionary = {
            'mozilla firefox': 'firefox',
            'firefox': 'firefox',
            'google chrome': 'chrome',
            'chrome': 'chrome',
            'microsoft edge': 'edge',
            'edge': 'edge',
            'safari': 'safari',
            'openssh': 'openssh',
            'ssh': 'openssh',
            'java': 'java',
            'openjdk': 'java',
            'oracle java': 'java',
            'dotnet': 'dotnet',
            '.net': 'dotnet',
            'python': 'python',
            'nodejs': 'nodejs',
            'node.js': 'nodejs',
            'spring framework': 'spring_framework',
            'apache': 'apache',
            'nginx': 'nginx',
            'iis': 'iis',
            'tomcat': 'tomcat',
            'webview2': 'chrome_webview2',
            'windows': 'windows',
            'linux': 'linux',
            'ubuntu': 'ubuntu',
            'centos': 'centos',
            'rhel': 'rhel',
            'red hat': 'rhel'
        };
        
        // Component targeting strategies
        this.componentStrategies = {
            // latest_supported: Always upgrade to approved latest version
            'firefox': { strategy: 'latest_supported', platform: 'app' },
            'chrome': { strategy: 'latest_supported', platform: 'app' },
            'edge': { strategy: 'latest_supported', platform: 'app' },
            'safari': { strategy: 'latest_supported', platform: 'app' },
            'chrome_webview2': { strategy: 'latest_supported', platform: 'app' },
            
            // branched_latest: Multiple supported version tracks
            'java': { strategy: 'branched_latest', platform: 'app' },
            'dotnet': { strategy: 'branched_latest', platform: 'app' },
            'python': { strategy: 'branched_latest', platform: 'app' },
            'nodejs': { strategy: 'branched_latest', platform: 'app' },
            
            // OS patch cycles
            'windows': { strategy: 'patch_cycle', platform: 'windows' },
            'ubuntu': { strategy: 'patch_cycle', platform: 'linux' },
            'centos': { strategy: 'patch_cycle', platform: 'linux' },
            'rhel': { strategy: 'patch_cycle', platform: 'linux' }
        };
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MAIN ANALYSIS PIPELINE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    analyzeAndGroup(rawVulnerabilities) {
        console.log('\nðŸ” â•â•â• ENHANCED ANALYSIS ENGINE V2 STARTED â•â•â•');
        console.log(`ðŸ“Š Total raw vulnerabilities: ${rawVulnerabilities.length}`);
        
        this.vulnerabilities = rawVulnerabilities;
        this.debugCount = 0;
        
        // Step 1: Normalize findings
        console.log('\nâš™ï¸  Step 1: Normalizing findings...');
        const normalized = this.normalizeFindings(rawVulnerabilities);
        console.log(`âœ… Normalized ${normalized.length} findings`);
        
        // Step 2: Classify remediation
        console.log('\nâš™ï¸  Step 2: Classifying remediation strategies...');
        const classified = this.classifyRemediation(normalized);
        console.log(`âœ… Classified ${classified.length} findings`);
        
        // Step 3: Group by remediation signature
        console.log('\nâš™ï¸  Step 3: Grouping by remediation signatures...');
        const groups = this.groupByRemediationSignature(classified);
        console.log(`âœ… Created ${groups.size} unique remediation groups`);
        
        // Step 4: Create POAMs
        console.log('\nâš™ï¸  Step 4: Building POAMs...');
        this.groupedPOAMs = this.buildPOAMs(groups);
        console.log(`âœ… Generated ${this.groupedPOAMs.length} POAMs`);
        
        // Step 5: Calculate confidence and flag reviews
        console.log('\nâš™ï¸  Step 5: Calculating confidence scores...');
        this.calculatePOAMConfidence();
        console.log(`âœ… Confidence scoring complete`);
        
        console.log('\nðŸŽ¯ â•â•â• ANALYSIS COMPLETE â•â•â•\n');
        
        return this.groupedPOAMs;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 1: NORMALIZE FINDINGS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    normalizeFindings(rawVulnerabilities) {
        return rawVulnerabilities.map((vuln, index) => {
            const title = vuln.title || '';
            const solution = vuln.solution || '';
            const results = vuln.results || '';
            const description = vuln.description || '';
            
            // Extract identifiers
            const cves = this.extractCVEs(vuln.cve);
            const qid = vuln.qid || '';
            const advisoryIds = this.extractAdvisoryIds(solution, title);
            const kbIds = this.extractKBIds(solution, title);
            
            // Extract asset info
            const asset = {
                assetId: vuln.asset || vuln.host || '',
                hostname: vuln.host || vuln.asset || '',
                ip: vuln.ip || '',
                operatingSystem: vuln.operatingSystem || this.detectOS(title, results),
                assetTags: vuln.assetTags || ''
            };
            
            // Extract evidence
            const currentVersion = this.extractCurrentVersion(results, title);
            const installedKBs = this.extractInstalledKBs(results);
            const missingKBs = kbIds;
            
            // Debug first 10 findings
            if (this.debugCount < 10) {
                console.log(`\nðŸ“‹ Finding #${this.debugCount}:`);
                console.log(`   Title: ${title.substring(0, 80)}`);
                console.log(`   CVEs: ${cves.join(', ') || 'none'}`);
                console.log(`   QID: ${qid}`);
                console.log(`   Advisory IDs: ${advisoryIds.join(', ') || 'none'}`);
                console.log(`   KB IDs: ${kbIds.join(', ') || 'none'}`);
                console.log(`   Current Version: ${currentVersion || 'unknown'}`);
                console.log(`   OS: ${asset.operatingSystem}`);
                this.debugCount++;
            }
            
            return {
                // Original data
                ...vuln,
                
                // Normalized identifiers
                identifiers: {
                    cves,
                    qid,
                    advisoryIds,
                    kbIds
                },
                
                // Asset info
                asset,
                
                // Text fields
                text: {
                    title,
                    description,
                    results,
                    solution
                },
                
                // Evidence
                evidence: {
                    currentVersion,
                    installedKBs,
                    missingKBs
                }
            };
        });
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 2: CLASSIFY REMEDIATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    classifyRemediation(findings) {
        return findings.map(finding => {
            const solution = finding.text.solution;
            const title = finding.text.title;
            const kbIds = finding.identifiers.kbIds;
            const advisoryIds = finding.identifiers.advisoryIds;
            
            // Determine remediation type (priority order)
            let remediationType = 'unknown';
            let fixedTarget = null;
            let fixedTargetKey = 'unknown';
            
            // 1. Check if patchable
            if (this.isNonPatchable(solution, finding)) {
                remediationType = 'operational_mitigation';
                fixedTargetKey = 'mitigation_required';
            }
            // 2. KB install
            else if (kbIds.length > 0) {
                remediationType = 'kb_install';
                fixedTarget = { kbIds };
                fixedTargetKey = kbIds.join('_');
            }
            // 3. Windows patch cycle
            else if (this.isWindowsPatchCycle(solution, title)) {
                remediationType = 'patch_cycle';
                const patchDate = this.extractPatchDate(solution, title);
                fixedTarget = { patchCycle: patchDate };
                fixedTargetKey = patchDate || 'unknown_cycle';
            }
            // 4. Software upgrade
            else if (this.isSoftwareUpgrade(solution)) {
                const version = this.extractFixedVersion(solution);
                remediationType = 'software_upgrade';
                fixedTarget = { version };
                fixedTargetKey = version || 'latest';
            }
            // 5. Vendor fix with bulletin
            else if (advisoryIds.length > 0) {
                remediationType = 'vendor_fix';
                fixedTarget = { advisoryIds };
                fixedTargetKey = advisoryIds.join('_');
            }
            // 6. Package upgrade (Linux)
            else if (this.isPackageUpgrade(solution, finding.asset.operatingSystem)) {
                remediationType = 'package_upgrade';
                const version = this.extractFixedVersion(solution);
                fixedTarget = { version };
                fixedTargetKey = version || 'latest';
            }
            else {
                remediationType = 'no_action_unknown';
                fixedTargetKey = 'review_required';
            }
            
            // Normalize component
            const component = this.normalizeComponent(title);
            const componentStrategy = this.componentStrategies[component] || { strategy: 'default', platform: 'app' };
            
            // Platform detection
            const platform = this.detectPlatform(finding.asset.operatingSystem, component);
            
            // Apply targeting strategy
            const targetingStrategy = componentStrategy.strategy;
            if (targetingStrategy === 'latest_supported' && remediationType === 'software_upgrade') {
                fixedTargetKey = 'latest';
            }
            else if (targetingStrategy === 'branched_latest' && remediationType === 'software_upgrade') {
                // Include major version in key
                const majorVersion = this.extractMajorVersion(fixedTarget?.version);
                fixedTargetKey = majorVersion ? `v${majorVersion}` : 'latest';
            }
            
            // Generate action text
            const actionText = this.generateActionText(remediationType, component, fixedTarget);
            
            return {
                ...finding,
                remediation: {
                    remediationType,
                    component,
                    platform,
                    targetingStrategy,
                    fixedTarget,
                    fixedTargetKey,
                    actionText
                }
            };
        });
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 3: GROUP BY REMEDIATION SIGNATURE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    groupByRemediationSignature(findings) {
        const groups = new Map();
        const signatureStats = new Map();
        
        findings.forEach((finding, index) => {
            const rem = finding.remediation;
            
            // Create remediation signature
            const signature = `${rem.platform}::${rem.remediationType}::${rem.component}::${rem.fixedTargetKey}`;
            
            // Track signature distribution
            signatureStats.set(signature, (signatureStats.get(signature) || 0) + 1);
            
            // Debug first 10 signatures
            if (index < 10) {
                console.log(`\nðŸ”‘ Signature #${index}:`);
                console.log(`   Component: ${rem.component}`);
                console.log(`   Type: ${rem.remediationType}`);
                console.log(`   Strategy: ${rem.targetingStrategy}`);
                console.log(`   Fixed Target: ${rem.fixedTargetKey}`);
                console.log(`   Platform: ${rem.platform}`);
                console.log(`   ðŸ“ Signature: ${signature}`);
                console.log(`   Action: ${rem.actionText}`);
            }
            
            if (!groups.has(signature)) {
                groups.set(signature, {
                    signature,
                    remediation: rem,
                    findings: [],
                    cves: new Set(),
                    qids: new Set(),
                    advisoryIds: new Set(),
                    assets: new Set(),
                    evidenceSamples: []
                });
            }
            
            const group = groups.get(signature);
            group.findings.push(finding);
            
            // Aggregate identifiers
            finding.identifiers.cves.forEach(cve => group.cves.add(cve));
            if (finding.identifiers.qid) group.qids.add(finding.identifiers.qid);
            finding.identifiers.advisoryIds.forEach(id => group.advisoryIds.add(id));
            
            // Track assets
            if (finding.asset.hostname) group.assets.add(finding.asset.hostname);
            
            // Collect evidence samples (max 3)
            if (group.evidenceSamples.length < 3 && finding.text.results) {
                group.evidenceSamples.push(finding.text.results.substring(0, 200));
            }
        });
        
        // Log signature distribution
        console.log('\nðŸ“Š Signature Distribution (Top 15):');
        const sortedSigs = Array.from(signatureStats.entries())
            .sort((a, b) => b[1] - a[1])
            .slice(0, 15);
        
        sortedSigs.forEach(([sig, count], index) => {
            console.log(`   ${index + 1}. ${sig.substring(0, 80)}`);
            console.log(`      â†’ ${count} findings`);
        });
        
        return groups;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 4: BUILD POAMs
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    buildPOAMs(groups) {
        const poams = [];
        let poamIdCounter = 1;
        
        groups.forEach((group, signature) => {
            const rem = group.remediation;
            
            // Generate POAM title (remediation-first, not CVE-first)
            const poamTitle = this.generatePOAMTitle(rem, group);
            
            // Determine recommended owner
            const recommendedOwner = this.determineOwner(rem.platform, rem.component);
            
            // Calculate due date based on risk
            const highestRisk = this.calculateHighestRisk(group.findings);
            const dueDate = this.calculateDueDate(highestRisk);
            
            const poam = {
                // Database required fields
                id: `POAM-${String(poamIdCounter).padStart(4, '0')}`,
                
                // Display fields
                title: poamTitle,
                description: rem.actionText,
                
                // Remediation metadata
                remediationSignature: signature,
                remediationType: rem.remediationType,
                component: rem.component,
                platform: rem.platform,
                targetingStrategy: rem.targetingStrategy,
                fixedTarget: rem.fixedTarget,
                fixedTargetKey: rem.fixedTargetKey,
                actionText: rem.actionText,
                
                // Status and tracking
                status: 'open',
                risk: highestRisk,
                dueDate: dueDate,
                createdDate: new Date().toISOString().split('T')[0],
                
                // Asset and finding counts
                assetCount: group.assets.size,
                findingCount: group.findings.length,
                
                // Aggregated data
                affectedAssets: Array.from(group.assets),
                asset: Array.from(group.assets).join(', '), // For database index
                cves: Array.from(group.cves),
                qids: Array.from(group.qids),
                advisoryIds: Array.from(group.advisoryIds),
                
                // Ownership
                poc: recommendedOwner,
                recommendedOwner,
                
                // Evidence
                evidenceSamples: group.evidenceSamples,
                
                // Confidence (will be calculated in step 5)
                confidenceScore: 0,
                needsReview: false,
                
                // Raw findings for drill-down
                rawFindings: group.findings
            };
            
            poams.push(poam);
            poamIdCounter++;
        });
        
        return poams;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 5: CALCULATE CONFIDENCE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    calculatePOAMConfidence() {
        this.groupedPOAMs.forEach(poam => {
            let score = 0;
            let maxScore = 0;
            
            // Advisory ID extracted (+40)
            maxScore += 40;
            if (poam.advisoryIds.length > 0) score += 40;
            
            // Fixed target extracted (+30)
            maxScore += 30;
            if (poam.fixedTarget && poam.fixedTargetKey !== 'unknown') score += 30;
            
            // Remediation type confidently classified (+20)
            maxScore += 20;
            if (poam.remediationType !== 'unknown' && poam.remediationType !== 'no_action_unknown') {
                score += 20;
            }
            
            // Component dictionary match (+15)
            maxScore += 15;
            if (this.componentDictionary[poam.component.toLowerCase()]) score += 15;
            
            // Current evidence extracted (+10)
            maxScore += 10;
            if (poam.evidenceSamples.length > 0) score += 10;
            
            poam.confidenceScore = Math.round((score / maxScore) * 100);
            poam.needsReview = poam.confidenceScore < 50 || poam.remediationType === 'no_action_unknown';
        });
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // EXTRACTION HELPERS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    extractCVEs(cveField) {
        if (!cveField) return [];
        return cveField.split(',')
            .map(c => c.trim())
            .filter(c => c.match(/CVE-\d{4}-\d+/i));
    }
    
    extractAdvisoryIds(solution, title) {
        const ids = [];
        const text = `${solution} ${title}`;
        
        // MFSA (Mozilla)
        const mfsa = text.match(/MFSA[\s-]?\d{4}-\d+/gi);
        if (mfsa) ids.push(...mfsa);
        
        // RHSA (Red Hat)
        const rhsa = text.match(/RHSA-\d{4}:\d+/gi);
        if (rhsa) ids.push(...rhsa);
        
        // MSRC (Microsoft)
        const msrc = text.match(/MS\d{2}-\d{3}/gi);
        if (msrc) ids.push(...msrc);
        
        // Generic vendor bulletins
        const bulletin = text.match(/[A-Z]{2,5}-\d{4}-\d+/g);
        if (bulletin) ids.push(...bulletin.filter(b => !b.match(/CVE-/)));
        
        return [...new Set(ids)];
    }
    
    extractKBIds(solution, title) {
        const text = `${solution} ${title}`;
        const kbs = text.match(/KB\d{6,}/gi);
        return kbs ? [...new Set(kbs.map(kb => kb.toUpperCase()))] : [];
    }
    
    extractCurrentVersion(results, title) {
        const text = `${results} ${title}`;
        const patterns = [
            /current version[:\s]+([\d.]+)/i,
            /installed version[:\s]+([\d.]+)/i,
            /version[:\s]+([\d.]+)\s+is installed/i,
            /running version[:\s]+([\d.]+)/i,
            /detected version[:\s]+([\d.]+)/i
        ];
        
        for (const pattern of patterns) {
            const match = text.match(pattern);
            if (match) return match[1];
        }
        return null;
    }
    
    extractInstalledKBs(results) {
        if (!results) return [];
        const kbs = results.match(/KB\d{6,}/gi);
        return kbs ? [...new Set(kbs.map(kb => kb.toUpperCase()))] : [];
    }
    
    extractFixedVersion(solution) {
        const patterns = [
            /upgrade to\s+(?:version\s+)?([\d.]+)/i,
            /update to\s+(?:version\s+)?([\d.]+)/i,
            /install\s+(?:version\s+)?([\d.]+)/i,
            /version\s+([\d.]+)\s+or\s+(?:later|higher)/i,
            /fixed in\s+(?:version\s+)?([\d.]+)/i
        ];
        
        for (const pattern of patterns) {
            const match = solution.match(pattern);
            if (match) return match[1];
        }
        return null;
    }
    
    extractPatchDate(solution, title) {
        const text = `${solution} ${title}`;
        
        // Look for YYYY-MM or Month YYYY patterns
        const yearMonth = text.match(/\b(20\d{2})[-\s](0[1-9]|1[0-2])\b/);
        if (yearMonth) return `${yearMonth[1]}-${yearMonth[2]}`;
        
        const monthYear = text.match(/\b(January|February|March|April|May|June|July|August|September|October|November|December)\s+(20\d{2})\b/i);
        if (monthYear) {
            const months = {january:1,february:2,march:3,april:4,may:5,june:6,july:7,august:8,september:9,october:10,november:11,december:12};
            const month = months[monthYear[1].toLowerCase()];
            return `${monthYear[2]}-${String(month).padStart(2, '0')}`;
        }
        
        return null;
    }
    
    extractMajorVersion(version) {
        if (!version) return null;
        const match = version.match(/^(\d+)/);
        return match ? match[1] : null;
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CLASSIFICATION HELPERS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    isNonPatchable(solution, finding) {
        const lower = solution.toLowerCase();
        return lower.includes('no solution available') || 
               lower.includes('no patch available') ||
               lower.includes('vendor has not released') ||
               (finding.vul && finding.vulnPatchable === 'No');
    }
    
    isWindowsPatchCycle(solution, title) {
        const text = `${solution} ${title}`.toLowerCase();
        return (text.includes('windows') || text.includes('microsoft')) &&
               (text.includes('security update') || text.includes('patch tuesday') || 
                text.match(/\b(20\d{2})[-\s](0[1-9]|1[0-2])\b/));
    }
    
    isSoftwareUpgrade(solution) {
        const lower = solution.toLowerCase();
        return lower.includes('upgrade to') || 
               lower.includes('update to') ||
               lower.includes('install version');
    }
    
    isPackageUpgrade(solution, os) {
        return (os === 'linux' || os === 'ubuntu' || os === 'centos' || os === 'rhel') &&
               (solution.includes('yum update') || solution.includes('apt-get') || solution.includes('dnf'));
    }
    
    detectOS(title, results) {
        const text = `${title} ${results}`.toLowerCase();
        if (text.includes('windows')) return 'windows';
        if (text.includes('linux')) return 'linux';
        if (text.includes('ubuntu')) return 'ubuntu';
        if (text.includes('centos')) return 'centos';
        if (text.includes('rhel') || text.includes('red hat')) return 'rhel';
        if (text.includes('mac') || text.includes('osx')) return 'mac';
        return 'unknown';
    }
    
    detectPlatform(os, component) {
        if (os === 'windows') return 'windows';
        if (os === 'linux' || os === 'ubuntu' || os === 'centos' || os === 'rhel') return 'linux';
        if (os === 'mac') return 'mac';
        
        // Fallback to component strategy
        const strategy = this.componentStrategies[component];
        return strategy ? strategy.platform : 'app';
    }
    
    normalizeComponent(title) {
        const lower = title.toLowerCase();
        
        // Try dictionary first
        for (const [key, value] of Object.entries(this.componentDictionary)) {
            if (lower.includes(key)) return value;
        }
        
        // Regex fallback
        const match = lower.match(/\b([a-z]+(?:\s+[a-z]+)?)\b/);
        return match ? match[1].replace(/\s+/g, '_') : 'unknown';
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // POAM GENERATION HELPERS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    generateActionText(remediationType, component, fixedTarget) {
        switch (remediationType) {
            case 'software_upgrade':
                return `Upgrade ${component} to version ${fixedTarget?.version || 'latest approved'}`;
            case 'package_upgrade':
                return `Update ${component} package to version ${fixedTarget?.version || 'latest'}`;
            case 'kb_install':
                return `Install KB updates: ${fixedTarget?.kbIds?.join(', ')}`;
            case 'patch_cycle':
                return `Apply ${fixedTarget?.patchCycle || 'monthly'} security patches`;
            case 'vendor_fix':
                return `Apply vendor fix per ${fixedTarget?.advisoryIds?.join(', ')}`;
            case 'operational_mitigation':
                return `Implement operational mitigation (no patch available)`;
            default:
                return `Review and remediate ${component} vulnerabilities`;
        }
    }
    
    generatePOAMTitle(remediation, group) {
        const component = remediation.component.replace(/_/g, ' ').toUpperCase();
        const assetCount = group.assets.size;
        const findingCount = group.findings.length;
        
        switch (remediation.remediationType) {
            case 'software_upgrade':
                return `${component} - Upgrade to ${remediation.fixedTargetKey} (${assetCount} assets, ${findingCount} findings)`;
            case 'patch_cycle':
                return `Windows ${remediation.fixedTargetKey} Patches (${assetCount} assets, ${findingCount} findings)`;
            case 'kb_install':
                return `${component} KB Updates (${assetCount} assets, ${findingCount} findings)`;
            case 'operational_mitigation':
                return `${component} - Operational Mitigation Required (${assetCount} assets, ${findingCount} findings)`;
            default:
                return `${component} - Multiple Vulnerabilities (${assetCount} assets, ${findingCount} findings)`;
        }
    }
    
    determineOwner(platform, component) {
        if (platform === 'windows') return 'Windows Systems Team';
        if (platform === 'linux') return 'Linux Systems Team';
        if (component === 'java' || component === 'dotnet') return 'Application Development Team';
        return 'Security Team';
    }
    
    calculateHighestRisk(findings) {
        const risks = findings.map(f => f.risk || f.severity || 'low');
        if (risks.some(r => r.toLowerCase().includes('critical'))) return 'critical';
        if (risks.some(r => r.toLowerCase().includes('high'))) return 'high';
        if (risks.some(r => r.toLowerCase().includes('medium'))) return 'medium';
        return 'low';
    }
    
    calculateDueDate(riskLevel) {
        const slaConfig = { critical: 15, high: 30, medium: 60, low: 90 };
        const days = slaConfig[riskLevel] || 30;
        const dueDate = new Date();
        dueDate.setDate(dueDate.getDate() + days);
        return dueDate.toISOString().split('T')[0];
    }
}

// Export for use
if (typeof module !== 'undefined' && module.exports) {
    module.exports = VulnerabilityAnalysisEngineV2;
}
