// Vulnerability Analysis Engine
// Intelligent grouping of vulnerabilities by fix/remediation strategy

console.log('âœ… vulnerability-analysis-engine.js loaded successfully');

class VulnerabilityAnalysisEngine {
    constructor() {
        this.vulnerabilities = [];
        this.groupedPOAMs = [];
    }

    // Main analysis function - groups vulnerabilities intelligently
    analyzeAndGroup(rawVulnerabilities) {
        console.log('ðŸ” ANALYSIS ENGINE STARTED');
        console.log(`ðŸ“Š Total raw vulnerabilities: ${rawVulnerabilities.length}`);
        
        this.vulnerabilities = rawVulnerabilities;
        this.debugCount = 0; // Initialize debug counter
        
        // Step 1: Extract remediation information
        console.log('âš™ï¸ Step 1: Enriching vulnerabilities with metadata...');
        const enrichedVulns = this.enrichWithRemediationData(rawVulnerabilities);
        console.log(`âœ… Enriched ${enrichedVulns.length} vulnerabilities`);
        
        // Step 2: Group by similar fix/version
        console.log('âš™ï¸ Step 2: Grouping by canonical keys...');
        const groups = this.groupBySimilarFix(enrichedVulns);
        console.log(`âœ… Created ${groups.length} groups`);
        
        // Step 3: Create consolidated POAMs
        console.log('âš™ï¸ Step 3: Creating consolidated POAMs...');
        this.groupedPOAMs = this.createConsolidatedPOAMs(groups);
        console.log(`âœ… Generated ${this.groupedPOAMs.length} POAMs`);
        
        return this.groupedPOAMs;
    }

    // Enrich vulnerabilities with remediation metadata
    enrichWithRemediationData(vulnerabilities) {
        return vulnerabilities.map(vuln => {
            const solution = vuln.solution || vuln.remediation || '';
            const title = vuln.title || vuln.vulnerability || '';
            const description = vuln.description || '';
            const results = vuln.results || '';
            
            // Extract current and target versions
            const currentVersion = this.extractCurrentVersion(results, title);
            const fixedTarget = this.extractFixedTarget(solution);
            
            // Determine remediation type
            const remediationType = this.determineRemediationType(solution, currentVersion, fixedTarget);
            
            // Calculate confidence score
            const confidence = this.calculateConfidence({
                hasCurrentVersion: !!currentVersion,
                hasFixedTarget: !!fixedTarget,
                hasSolution: !!solution,
                hasProduct: !!this.normalizeProduct(title)
            });
            
            return {
                ...vuln,
                remediation: {
                    solution: solution,
                    currentVersion: currentVersion,
                    fixedTarget: fixedTarget,
                    remediationType: remediationType,
                    confidence: confidence,
                    versions: this.extractVersions(solution),
                    patchType: this.determinePatchType(solution, title),
                    vendor: this.extractVendor(title, solution),
                    product: this.normalizeProduct(title),
                    fixAction: this.extractFixAction(solution),
                    patchDate: this.extractPatchDate(solution, title),
                    category: this.classifyVulnerability(title, solution),
                    requiredVersion: this.extractRequiredVersion(solution, title),
                    solutionHash: this.normalizeSolution(solution)
                }
            };
        });
    }

    // Extract current version from Results field
    extractCurrentVersion(results, title) {
        if (!results && !title) return null;
        
        const text = `${results} ${title}`;
        
        // Look for version patterns in results
        const patterns = [
            /current version[:\s]+([\d.]+)/i,
            /installed version[:\s]+([\d.]+)/i,
            /version[:\s]+([\d.]+)\s+is installed/i,
            /running version[:\s]+([\d.]+)/i,
            /detected version[:\s]+([\d.]+)/i,
            /([\d.]+)\s+is vulnerable/i,
            /version\s+([\d.]+)/i
        ];
        
        for (const pattern of patterns) {
            const match = text.match(pattern);
            if (match && match[1]) {
                return match[1].trim();
            }
        }
        
        return null;
    }

    // Extract fixed/target version from Solution field
    extractFixedTarget(solution) {
        if (!solution) return null;
        
        // Look for target version patterns
        const patterns = [
            /upgrade to\s+(?:version\s+)?([\d.]+)/i,
            /update to\s+(?:version\s+)?([\d.]+)/i,
            /install\s+(?:version\s+)?([\d.]+)/i,
            /apply\s+(?:version\s+)?([\d.]+)/i,
            /version\s+([\d.]+)\s+or\s+(?:later|higher|above)/i,
            /([\d.]+)\s+or\s+(?:later|higher|newer)/i,
            /fixed in\s+(?:version\s+)?([\d.]+)/i,
            /patched in\s+(?:version\s+)?([\d.]+)/i
        ];
        
        for (const pattern of patterns) {
            const match = solution.match(pattern);
            if (match && match[1]) {
                return match[1].trim();
            }
        }
        
        return null;
    }

    // Determine remediation type
    determineRemediationType(solution, currentVersion, fixedTarget) {
        if (!solution) return 'unknown';
        
        const lower = solution.toLowerCase();
        
        // Check for version upgrade
        if (currentVersion && fixedTarget) {
            const current = this.parseVersion(currentVersion);
            const target = this.parseVersion(fixedTarget);
            
            if (current && target) {
                const comparison = this.compareVersions(fixedTarget, currentVersion);
                if (comparison > 0) {
                    // Check if major version change
                    if (current.major !== target.major) {
                        return 'major_upgrade';
                    } else if (current.minor !== target.minor) {
                        return 'minor_upgrade';
                    } else {
                        return 'patch_upgrade';
                    }
                }
            }
        }
        
        // Keyword-based classification
        if (lower.includes('upgrade') || lower.includes('update')) return 'upgrade';
        if (lower.includes('patch') || lower.includes('hotfix')) return 'patch';
        if (lower.includes('configure') || lower.includes('disable') || lower.includes('enable')) return 'configuration';
        if (lower.includes('remove') || lower.includes('uninstall')) return 'removal';
        if (lower.includes('workaround') || lower.includes('mitigate')) return 'workaround';
        
        return 'other';
    }

    // Parse version string into components
    parseVersion(versionStr) {
        if (!versionStr) return null;
        
        const parts = versionStr.split('.').map(p => parseInt(p) || 0);
        return {
            major: parts[0] || 0,
            minor: parts[1] || 0,
            patch: parts[2] || 0,
            build: parts[3] || 0
        };
    }

    // Calculate confidence score for grouping
    calculateConfidence(factors) {
        let score = 0;
        let maxScore = 0;
        
        // Has current version (20 points)
        maxScore += 20;
        if (factors.hasCurrentVersion) score += 20;
        
        // Has fixed target (30 points)
        maxScore += 30;
        if (factors.hasFixedTarget) score += 30;
        
        // Has solution text (25 points)
        maxScore += 25;
        if (factors.hasSolution) score += 25;
        
        // Has product identification (25 points)
        maxScore += 25;
        if (factors.hasProduct) score += 25;
        
        return Math.round((score / maxScore) * 100);
    }

    // Normalize solution text for grouping
    // Creates a stable hash from the solution to group similar fixes together
    normalizeSolution(solution) {
        if (!solution) return 'no_solution';
        
        // Light normalization - preserve most of the solution text
        // Only remove truly redundant words
        let normalized = solution.toLowerCase()
            .replace(/please\s+/gi, '')
            .replace(/kindly\s+/gi, '')
            .trim()
            .replace(/[^a-z0-9\s.]/g, ' ')  // Keep periods for version numbers
            .replace(/\s+/g, ' ')
            .substring(0, 200); // First 200 chars to preserve detail
        
        // Create a simple hash to keep it manageable
        let hash = 0;
        for (let i = 0; i < normalized.length; i++) {
            const char = normalized.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32bit integer
        }
        
        // Return hash as hex + first 30 chars of normalized text for readability
        const shortText = normalized.substring(0, 30).replace(/\s+/g, '_');
        return `${Math.abs(hash).toString(16)}_${shortText}`;
    }

    // Extract primary vulnerability ID (CVE > QID > Plugin ID)
    extractPrimaryId(title, description) {
        const text = `${title} ${description}`;
        
        // Priority 1: CVE
        const cveMatch = text.match(/CVE-\d{4}-\d{4,7}/i);
        if (cveMatch) {
            return cveMatch[0].toUpperCase();
        }
        
        // Priority 2: QID (Qualys)
        const qidMatch = text.match(/QID[:\s]*(\d+)/i);
        if (qidMatch) {
            return `QID-${qidMatch[1]}`;
        }
        
        // Priority 3: Plugin ID (Nessus)
        const pluginMatch = text.match(/Plugin\s+ID[:\s]*(\d+)/i);
        if (pluginMatch) {
            return `PLUGIN-${pluginMatch[1]}`;
        }
        
        // No ID found - use title hash
        return 'UNKNOWN';
    }

    // Normalize product name
    normalizeProduct(title) {
        if (!title) return 'unknown';
        
        const lower = title.toLowerCase();
        
        // Common product mappings
        if (lower.includes('firefox') || lower.includes('mozilla')) return 'firefox';
        if (lower.includes('chrome') || lower.includes('chromium')) return 'chrome';
        if (lower.includes('windows')) return 'windows';
        if (lower.includes('apache')) return 'apache';
        if (lower.includes('nginx')) return 'nginx';
        if (lower.includes('openssh') || lower.includes('ssh')) return 'openssh';
        if (lower.includes('openssl') || lower.includes('ssl')) return 'openssl';
        if (lower.includes('mysql')) return 'mysql';
        if (lower.includes('postgresql')) return 'postgresql';
        if (lower.includes('tomcat')) return 'tomcat';
        if (lower.includes('java')) return 'java';
        if (lower.includes('python')) return 'python';
        if (lower.includes('php')) return 'php';
        
        // Extract first word as product
        const words = title.split(/[\s\-:]/);
        return words[0] ? words[0].toLowerCase() : 'unknown';
    }

    // Extract required version (full semantic version)
    // Picks the highest version if multiple are mentioned
    extractRequiredVersion(solution, title) {
        const versions = this.extractVersions(solution + ' ' + title);
        if (versions.length === 0) return null;
        
        // If multiple versions found, pick the highest one
        if (versions.length > 1) {
            return this.getHighestVersion(versions);
        }
        
        // Return full semantic version (major.minor.patch.build)
        return versions[0];
    }

    // Compare and return the highest version from a list
    getHighestVersion(versions) {
        return versions.reduce((highest, current) => {
            return this.compareVersions(current, highest) > 0 ? current : highest;
        });
    }

    // Compare two version strings
    // Returns: 1 if v1 > v2, -1 if v1 < v2, 0 if equal
    compareVersions(v1, v2) {
        const parts1 = v1.split('.').map(p => parseInt(p) || 0);
        const parts2 = v2.split('.').map(p => parseInt(p) || 0);
        
        const maxLength = Math.max(parts1.length, parts2.length);
        
        for (let i = 0; i < maxLength; i++) {
            const p1 = parts1[i] || 0;
            const p2 = parts2[i] || 0;
            
            if (p1 > p2) return 1;
            if (p1 < p2) return -1;
        }
        
        return 0;
    }

    // Classify vulnerability by type/category
    classifyVulnerability(title, solution) {
        const text = (title + ' ' + solution).toLowerCase();
        
        // SSL/TLS related
        if (text.includes('ssl') || text.includes('tls') || text.includes('certificate') || 
            text.includes('cipher') || text.includes('https')) {
            return 'SSL/TLS';
        }
        
        // Authentication/Access Control
        if (text.includes('authentication') || text.includes('password') || text.includes('credential') ||
            text.includes('login') || text.includes('access control')) {
            return 'Authentication';
        }
        
        // Encryption/Cryptography
        if (text.includes('encryption') || text.includes('cryptograph') || text.includes('hash')) {
            return 'Cryptography';
        }
        
        // Web Application vulnerabilities
        if (text.includes('xss') || text.includes('cross-site') || text.includes('sql injection') ||
            text.includes('csrf') || text.includes('injection')) {
            return 'Web Application';
        }
        
        // Configuration issues
        if (text.includes('misconfiguration') || text.includes('default') || text.includes('hardening')) {
            return 'Configuration';
        }
        
        // End of Life / Unsupported
        if (text.includes('end of life') || text.includes('eol') || text.includes('unsupported') ||
            text.includes('obsolete')) {
            return 'End of Life';
        }
        
        // Missing patches/updates
        if (text.includes('patch') || text.includes('update') || text.includes('security bulletin') ||
            text.includes('kb') || text.includes('hotfix')) {
            return 'Security Patch';
        }
        
        // Default to 'General'
        return 'General';
    }

    // Extract version numbers from solution text
    extractVersions(text) {
        if (!text) return [];
        
        const versionPatterns = [
            /version\s+(\d+\.[\d.]+)/gi,
            /v(\d+\.[\d.]+)/gi,
            /(\d+\.[\d.]+)\s+or\s+later/gi,
            /upgrade\s+to\s+(\d+\.[\d.]+)/gi,
            /patch\s+(\d+\.[\d.]+)/gi
        ];
        
        const versions = new Set();
        versionPatterns.forEach(pattern => {
            const matches = text.matchAll(pattern);
            for (const match of matches) {
                versions.add(match[1]);
            }
        });
        
        return Array.from(versions);
    }

    // Determine the type of patch/fix required
    determinePatchType(solution, title) {
        const text = (solution + ' ' + title).toLowerCase();
        
        if (text.includes('upgrade') || text.includes('update')) return 'upgrade';
        if (text.includes('patch')) return 'patch';
        if (text.includes('configuration') || text.includes('disable')) return 'configuration';
        if (text.includes('workaround')) return 'workaround';
        if (text.includes('replace') || text.includes('remove')) return 'replacement';
        
        return 'other';
    }

    // Extract vendor name
    extractVendor(title, solution) {
        const text = (title + ' ' + solution).toLowerCase();
        
        const vendors = [
            'microsoft', 'adobe', 'oracle', 'cisco', 'vmware', 'apache',
            'openssl', 'linux', 'redhat', 'ubuntu', 'debian', 'centos',
            'windows', 'java', 'python', 'php', 'nodejs', 'nginx',
            'tomcat', 'jboss', 'weblogic', 'iis', 'chrome', 'firefox'
        ];
        
        for (const vendor of vendors) {
            if (text.includes(vendor)) {
                return vendor.charAt(0).toUpperCase() + vendor.slice(1);
            }
        }
        
        return 'Unknown';
    }

    // Extract product name
    extractProduct(title, solution) {
        const productMatch = title.match(/^([^-:]+)/);
        return productMatch ? productMatch[1].trim() : 'Unknown Product';
    }

    // Extract the primary fix action
    extractFixAction(solution) {
        if (!solution) return 'Review and remediate';
        
        const text = solution.toLowerCase();
        
        if (text.includes('upgrade to')) {
            const match = solution.match(/upgrade to ([^\n.]+)/i);
            return match ? `Upgrade to ${match[1].trim()}` : 'Upgrade to latest version';
        }
        
        if (text.includes('apply patch')) {
            const match = solution.match(/apply patch ([^\n.]+)/i);
            return match ? `Apply patch ${match[1].trim()}` : 'Apply security patch';
        }
        
        if (text.includes('disable')) {
            const match = solution.match(/disable ([^\n.]+)/i);
            return match ? `Disable ${match[1].trim()}` : 'Disable vulnerable feature';
        }
        
        // Return first sentence as fix action
        const firstSentence = solution.split(/[.\n]/)[0];
        return firstSentence.substring(0, 100);
    }

    // Extract patch date/month for Windows updates
    extractPatchDate(solution, title) {
        if (!solution && !title) return null;
        
        const text = (solution + ' ' + title).toLowerCase();
        
        // Look for month/year patterns (e.g., "December 2024", "2024-12", "Dec 2024")
        const monthYearPatterns = [
            /(january|february|march|april|may|june|july|august|september|october|november|december)\s+(\d{4})/i,
            /(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\s+(\d{4})/i,
            /(\d{4})[-/](0?[1-9]|1[0-2])/,  // 2024-12 or 2024/12
            /(0?[1-9]|1[0-2])[-/](\d{4})/   // 12-2024 or 12/2024
        ];
        
        for (const pattern of monthYearPatterns) {
            const match = text.match(pattern);
            if (match) {
                // Normalize to "Month YYYY" format
                if (match[1] && match[2]) {
                    const month = match[1].charAt(0).toUpperCase() + match[1].slice(1).toLowerCase();
                    return `${month} ${match[2]}`;
                } else if (match[1] && match[1].length === 4) {
                    // Format: YYYY-MM
                    const monthNum = parseInt(match[2]);
                    const months = ['January', 'February', 'March', 'April', 'May', 'June', 
                                  'July', 'August', 'September', 'October', 'November', 'December'];
                    return `${months[monthNum - 1]} ${match[1]}`;
                } else if (match[2] && match[2].length === 4) {
                    // Format: MM-YYYY
                    const monthNum = parseInt(match[1]);
                    const months = ['January', 'February', 'March', 'April', 'May', 'June', 
                                  'July', 'August', 'September', 'October', 'November', 'December'];
                    return `${months[monthNum - 1]} ${match[2]}`;
                }
            }
        }
        
        return null;
    }

    // Group vulnerabilities by similar fix strategy
    groupBySimilarFix(vulnerabilities) {
        const groups = new Map();
        const keyDistribution = new Map(); // Track how many vulns per key
        
        vulnerabilities.forEach(vuln => {
            const key = this.createGroupingKey(vuln);
            
            // Track key distribution
            keyDistribution.set(key, (keyDistribution.get(key) || 0) + 1);
            
            if (!groups.has(key)) {
                groups.set(key, {
                    key: key,
                    vulnerabilities: [],
                    affectedAssets: new Set(),
                    cveList: new Set(),
                    versions: vuln.remediation.versions || [],
                    highestRisk: 'low',
                    product: vuln.remediation.product,
                    vendor: vuln.remediation.vendor
                });
            }
            
            const targetGroup = groups.get(key);
            targetGroup.vulnerabilities.push(vuln);
            
            // Track unique assets
            if (vuln.host || vuln.asset) {
                targetGroup.affectedAssets.add(vuln.host || vuln.asset);
            }
            
            // Track CVEs
            if (vuln.cve) {
                const cves = vuln.cve.split(',').map(c => c.trim()).filter(c => c);
                cves.forEach(cve => targetGroup.cveList.add(cve));
            }
            
            // Update highest risk
            targetGroup.highestRisk = this.getHigherRisk(targetGroup.highestRisk, vuln.severity || vuln.risk || 'low');
        });
        
        // Log grouping statistics
        console.log('\nðŸ“Š GROUPING STATISTICS:');
        console.log(`   Total Vulnerabilities: ${vulnerabilities.length}`);
        console.log(`   Unique Groups Created: ${groups.size}`);
        console.log(`   Average Vulns per Group: ${(vulnerabilities.length / groups.size).toFixed(2)}`);
        
        // Show top 10 largest groups
        const sortedKeys = Array.from(keyDistribution.entries())
            .sort((a, b) => b[1] - a[1])
            .slice(0, 10);
        
        console.log('\nðŸ” Top 10 Largest Groups:');
        sortedKeys.forEach(([key, count], index) => {
            console.log(`   ${index + 1}. ${key.substring(0, 80)} â†’ ${count} vulnerabilities`);
        });
        console.log('');
        
        return Array.from(groups.values());
    }

    // Create a grouping key for similar vulnerabilities
    // Uses remediationType + fixedTarget canonical key
    // This groups findings with the same remediation action together
    createGroupingKey(vuln) {
        const product = vuln.remediation.product || 'unknown';
        const remediationType = vuln.remediation.remediationType || 'unknown';
        const fixedTarget = vuln.remediation.fixedTarget || 'n/a';
        const currentVersion = vuln.remediation.currentVersion || 'unknown';
        const patchDate = vuln.remediation.patchDate;
        const confidence = vuln.remediation.confidence || 0;
        const title = vuln.title || vuln.vulnerability || '';
        const solution = vuln.remediation.solution || '';
        
        // Comprehensive debug logging (first 10 vulnerabilities)
        if (!this.debugCount || this.debugCount < 10) {
            console.log(`\nðŸ”‘ Grouping Debug #${this.debugCount || 0}:`);
            console.log(`   Title: ${title.substring(0, 100)}`);
            console.log(`   Solution: ${solution.substring(0, 100)}`);
            console.log(`   Product: ${product}`);
            console.log(`   Current Version: ${currentVersion}`);
            console.log(`   Fixed Target: ${fixedTarget}`);
            console.log(`   Remediation Type: ${remediationType}`);
            console.log(`   Confidence Score: ${confidence}%`);
            console.log(`   Patch Date: ${patchDate || 'N/A'}`);
            
            const key = `${product}::${remediationType}::${fixedTarget}`;
            console.log(`   Generated Key: ${key}`);
            console.log(`   âœ… Confidence: ${this.getConfidenceLabel(confidence)}\n`);
            
            this.debugCount = (this.debugCount || 0) + 1;
        }
        
        // Special handling for Windows patches - group by MONTH
        if (product === 'windows' && patchDate) {
            return `${product}::WINDOWS_PATCH::${patchDate}`.toLowerCase();
        }
        
        // Canonical key: product::remediationType::fixedTarget
        // Same product + same remediation type + same target version = ONE POAM
        // Example: "firefox::upgrade::123.0.6312.122"
        // Example: "apache::patch_upgrade::2.4.58"
        // Example: "openssh::major_upgrade::9.5"
        return `${product}::${remediationType}::${fixedTarget}`.toLowerCase();
    }

    // Get confidence label for debug output
    getConfidenceLabel(score) {
        if (score >= 90) return 'ðŸŸ¢ EXCELLENT';
        if (score >= 70) return 'ðŸŸ¡ GOOD';
        if (score >= 50) return 'ðŸŸ  FAIR';
        return 'ðŸ”´ LOW';
    }
    
    // Extract clean product name for better grouping
    extractCleanProductName(title) {
        // Common product patterns
        const productPatterns = [
            /^(windows\s+server\s+\d+)/i,
            /^(windows\s+\d+)/i,
            /^(windows)/i,
            /^(mozilla\s+firefox)/i,
            /^(firefox)/i,
            /^(openssh)/i,
            /^(apache\s+\w+)/i,
            /^(nginx)/i,
            /^(openssl)/i,
            /^(java\s+\w+)/i,
            /^(python)/i,
            /^(php)/i,
            /^(mysql)/i,
            /^(postgresql)/i,
            /^(docker)/i,
            /^(kubernetes)/i,
            /^(\w+)\s+\d+\.\d+/i, // Generic "Product X.Y"
            /^([^-:]+)/i // Everything before first dash or colon
        ];
        
        for (const pattern of productPatterns) {
            const match = title.match(pattern);
            if (match) {
                return match[1].trim();
            }
        }
        
        return title.split(/[-:]/)[0].trim() || 'Unknown Product';
    }

    // Compare risk levels and return higher one
    getHigherRisk(risk1, risk2) {
        const riskOrder = { 'critical': 4, 'high': 3, 'medium': 2, 'low': 1 };
        const r1 = riskOrder[risk1.toLowerCase()] || 1;
        const r2 = riskOrder[risk2.toLowerCase()] || 1;
        
        return r1 >= r2 ? risk1 : risk2;
    }

    // Create consolidated POAMs from groups
    createConsolidatedPOAMs(groups) {
        return groups.map((group, index) => {
            const poamId = `POAM-${Date.now()}-${index}`;
            const affectedAssetsArray = Array.from(group.affectedAssets);
            const cveArray = Array.from(group.cveList);
            
            return {
                id: poamId,
                title: this.generatePOAMTitle(group),
                description: this.generatePOAMDescription(group),
                risk: group.highestRisk,
                status: 'open',
                vendor: group.vendor,
                product: group.product,
                patchType: group.patchType,
                fixAction: group.fixAction,
                affectedAssets: affectedAssetsArray,
                assetCount: affectedAssetsArray.length,
                vulnerabilityCount: group.vulnerabilities.length,
                cves: cveArray,
                rawVulnerabilities: group.vulnerabilities,
                dueDate: this.calculateDueDate(group.highestRisk),
                createdDate: new Date().toISOString(),
                poc: 'Unassigned',
                dependencies: [],
                milestones: [],
                source: 'Vulnerability Scan Analysis',
                remediationSteps: this.generateRemediationSteps(group)
            };
        });
    }

    // Generate a clear POAM title
    generatePOAMTitle(group) {
        const { vulnerabilityCount, versions } = group;
        
        // Extract clean product name from first vulnerability
        const cleanProduct = group.vulnerabilities[0] ? 
            this.extractCleanProductName(group.vulnerabilities[0].title || group.vulnerabilities[0].vulnerability || '') :
            'Unknown Product';
        
        // Special handling for Windows patches with dates
        if (cleanProduct.toLowerCase().includes('windows')) {
            const patchDate = group.vulnerabilities[0]?.remediation?.patchDate;
            if (patchDate) {
                return `Windows ${patchDate} Security Updates`;
            }
            return `Windows Security Patches`;
        }
        
        // Version-based grouping title
        if (versions && versions.length > 0) {
            const targetVersion = versions[0]; // Primary version
            
            if (vulnerabilityCount > 1) {
                return `${cleanProduct} - Upgrade to v${targetVersion} (${vulnerabilityCount} vulnerabilities)`;
            } else {
                return `${cleanProduct} - Upgrade to v${targetVersion}`;
            }
        }
        
        // No version - use fix action based title
        if (vulnerabilityCount > 1) {
            return `${cleanProduct} - Multiple Vulnerabilities (${vulnerabilityCount} findings)`;
        } else {
            // Single vulnerability - use the actual title
            return group.vulnerabilities[0]?.title || group.vulnerabilities[0]?.vulnerability || `${cleanProduct} - Security Issue`;
        }
    }

    // Generate detailed POAM description
    generatePOAMDescription(group) {
        const { vulnerabilityCount, affectedAssets, fixAction } = group;
        
        return `This POAM consolidates ${vulnerabilityCount} related vulnerabilities affecting ${affectedAssets.size} asset(s). 
        
Primary Remediation: ${fixAction}

All vulnerabilities in this POAM share a common remediation strategy and can be addressed together, reducing the total number of POAMs while maintaining comprehensive tracking.`;
    }

    // Generate step-by-step remediation
    generateRemediationSteps(group) {
        const steps = [];
        
        steps.push({
            step: 1,
            action: 'Review affected assets',
            description: `Identify all ${group.affectedAssets.size} affected systems`,
            status: 'pending'
        });
        
        steps.push({
            step: 2,
            action: 'Test remediation',
            description: `Test ${group.fixAction} in non-production environment`,
            status: 'pending'
        });
        
        steps.push({
            step: 3,
            action: 'Schedule maintenance window',
            description: 'Coordinate with asset owners for deployment',
            status: 'pending'
        });
        
        steps.push({
            step: 4,
            action: 'Apply fix',
            description: `Deploy ${group.fixAction} to all affected systems`,
            status: 'pending'
        });
        
        steps.push({
            step: 5,
            action: 'Verify remediation',
            description: 'Rescan systems to confirm vulnerabilities are resolved',
            status: 'pending'
        });
        
        return steps;
    }

    // Calculate due date based on risk
    calculateDueDate(risk) {
        const now = new Date();
        const riskDays = {
            'critical': 15,
            'high': 30,
            'medium': 60,
            'low': 90
        };
        
        const days = riskDays[risk.toLowerCase()] || 60;
        const dueDate = new Date(now.getTime() + (days * 24 * 60 * 60 * 1000));
        
        return dueDate.toISOString().split('T')[0];
    }

    // Get statistics about the analysis
    getAnalysisStats() {
        return {
            totalVulnerabilities: this.vulnerabilities.length,
            totalPOAMs: this.groupedPOAMs.length,
            reductionPercentage: this.vulnerabilities.length > 0 
                ? Math.round((1 - this.groupedPOAMs.length / this.vulnerabilities.length) * 100)
                : 0,
            byRisk: this.groupedPOAMs.reduce((acc, poam) => {
                acc[poam.risk] = (acc[poam.risk] || 0) + 1;
                return acc;
            }, {}),
            byPatchType: this.groupedPOAMs.reduce((acc, poam) => {
                acc[poam.patchType] = (acc[poam.patchType] || 0) + 1;
                return acc;
            }, {})
        };
    }
}

// Export for use in other modules
window.VulnerabilityAnalysisEngine = VulnerabilityAnalysisEngine;
